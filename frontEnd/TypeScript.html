<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript (基础) | 久念的个人博客</title>
    <meta name="description" content="村上春树说过:总之岁月漫长，然而值得等待">
    <link rel="icon" href="../.vuepress/public/img/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.2412c64d.css" as="style"><link rel="preload" href="/assets/js/app.27194c62.js" as="script"><link rel="preload" href="/assets/js/2.660d2c2d.js" as="script"><link rel="preload" href="/assets/js/14.e7071a84.js" as="script"><link rel="prefetch" href="/assets/js/10.7e6638b6.js"><link rel="prefetch" href="/assets/js/11.3c882514.js"><link rel="prefetch" href="/assets/js/12.8f14a644.js"><link rel="prefetch" href="/assets/js/13.7ad68c93.js"><link rel="prefetch" href="/assets/js/15.c868008a.js"><link rel="prefetch" href="/assets/js/16.96d600e7.js"><link rel="prefetch" href="/assets/js/17.216bbb18.js"><link rel="prefetch" href="/assets/js/18.132d27eb.js"><link rel="prefetch" href="/assets/js/19.94321978.js"><link rel="prefetch" href="/assets/js/20.5ff51867.js"><link rel="prefetch" href="/assets/js/21.5034d234.js"><link rel="prefetch" href="/assets/js/22.6e708266.js"><link rel="prefetch" href="/assets/js/23.afc937fb.js"><link rel="prefetch" href="/assets/js/24.6a2d27de.js"><link rel="prefetch" href="/assets/js/25.40bacf7a.js"><link rel="prefetch" href="/assets/js/26.94f1f69e.js"><link rel="prefetch" href="/assets/js/27.9009e8ee.js"><link rel="prefetch" href="/assets/js/28.d79333d2.js"><link rel="prefetch" href="/assets/js/29.3451956d.js"><link rel="prefetch" href="/assets/js/3.25a26ba3.js"><link rel="prefetch" href="/assets/js/30.601df3fc.js"><link rel="prefetch" href="/assets/js/31.80e18c66.js"><link rel="prefetch" href="/assets/js/32.e6dd8fca.js"><link rel="prefetch" href="/assets/js/33.beab8789.js"><link rel="prefetch" href="/assets/js/34.7a02303d.js"><link rel="prefetch" href="/assets/js/4.f74a38f4.js"><link rel="prefetch" href="/assets/js/5.4c28bf85.js"><link rel="prefetch" href="/assets/js/6.11aca216.js"><link rel="prefetch" href="/assets/js/7.8d7844b8.js"><link rel="prefetch" href="/assets/js/8.56426901.js"><link rel="prefetch" href="/assets/js/9.ecc15e63.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2412c64d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">久念的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/frontEnd/" class="nav-link router-link-active">前端基础</a></div><div class="nav-item"><a href="/interviewEnd/" class="nav-link">有关面试</a></div><div class="nav-item"><a href="/myEnd/" class="nav-link">个人随笔</a></div><div class="nav-item"><a href="/backEnd/" class="nav-link">优文转载</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术论坛" class="dropdown-title"><span class="title">技术论坛</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.im/timeline" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.jianshu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/frontEnd/" class="nav-link router-link-active">前端基础</a></div><div class="nav-item"><a href="/interviewEnd/" class="nav-link">有关面试</a></div><div class="nav-item"><a href="/myEnd/" class="nav-link">个人随笔</a></div><div class="nav-item"><a href="/backEnd/" class="nav-link">优文转载</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术论坛" class="dropdown-title"><span class="title">技术论坛</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.im/timeline" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.jianshu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/frontEnd/" class="sidebar-link">简述vue</a></li><li><a href="/frontEnd/test.html" class="sidebar-link">vuex</a></li><li><a href="/frontEnd/vue.html" class="sidebar-link">vue脚手架&amp;路由</a></li><li><a href="/frontEnd/MVVM.html" class="sidebar-link">vue源码解析</a></li><li><a href="/frontEnd/React.html" class="sidebar-link">React</a></li><li><a href="/frontEnd/React-router.html" class="sidebar-link">React-router</a></li><li><a href="/frontEnd/Redux.html" class="sidebar-link">Redux</a></li><li><a href="/frontEnd/React-ui.html" class="sidebar-link">最流行的开源React UI组件库</a></li><li><a href="/frontEnd/wxmin.html" class="sidebar-link">小程序</a></li><li><a href="/frontEnd/ajax.html" class="sidebar-link">ajax</a></li><li><a href="/frontEnd/es6.html" class="sidebar-link">ES6</a></li><li><a href="/frontEnd/TypeScript.html" class="active sidebar-link">TypeScript (基础)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#typescript是什么？" class="sidebar-link">TypeScript是什么？</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#typescript-配置" class="sidebar-link">TypeScript 配置</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️基础类型" class="sidebar-link">⭐️基础类型</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️数组类型" class="sidebar-link">⭐️数组类型</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️any-类型-任意值" class="sidebar-link">⭐️any 类型(任意值)</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️interface-接口" class="sidebar-link">⭐️interface 接口</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️函数类型" class="sidebar-link">⭐️函数类型</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️类型断言" class="sidebar-link">⭐️类型断言</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️declare-声明" class="sidebar-link">⭐️declare 声明</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️内置对象" class="sidebar-link">⭐️内置对象</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐类型推论" class="sidebar-link">⭐类型推论</a></li><li class="sidebar-sub-header"><a href="/frontEnd/TypeScript.html#⭐️联合类型" class="sidebar-link">⭐️联合类型</a></li></ul></li><li><a href="/frontEnd/ts.html" class="sidebar-link">TypeScript (进阶)</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="typescript-基础"><a href="#typescript-基础" class="header-anchor">#</a> TypeScript (基础)</h1> <h2 id="typescript是什么？"><a href="#typescript是什么？" class="header-anchor">#</a> TypeScript是什么？</h2> <ul><li><p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p></li> <li><p>以下内容均出自于 TS入门教程</p></li> <li><p>以及 Ts 官网的一些内容，没有基础的小伙伴直接看打了⭐️的内容即可。</p></li></ul> <h2 id="typescript-配置"><a href="#typescript-配置" class="header-anchor">#</a> TypeScript 配置</h2> <ul><li>为什么配置？ TypeScript 还有一个二进制文件，可将 TypeScript 代码编译为 JS 代码. 请记住，浏览器不能编译运行 TypeScript：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>mkdir typescript-tutorial &amp;&amp; cd $_
npm init -y
</code></pre></div><ul><li>然后安装 TypeScript</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm i typescript --save-dev
</code></pre></div><ul><li>接下来在 package.json 中的 scripts 下添加如下内容，以便咱们可以轻松地运行 TypeScript 编译器：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  &quot;scripts&quot;: {
    &quot;tsc&quot;: &quot;tsc&quot;
  }
</code></pre></div><ul><li>tsc 代表 TypeScript 编译器，只要编译器运行，它将在项目文件夹中查找名为tsconfig.json 的文件。 使用以下命令为 TypeScript 生成配置文件：</li></ul> <p><code>npm run tsc -- --init</code></p> <ul><li><p>执行成功后会在控制台收到 message TS6071: Successfully created a tsconfig.json file。在项目文件夹中会看到新增了一个 tsconfig.json 文件。tsconfig。json 是一个可怕的配置文件，不要慌。咱们不需要知道它的每一个要点，在下一节中，会介绍入门的相关部分。</p></li> <li><p>创建文件夹</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>mkdir demo
cd demo
touch 1.ts
</code></pre></div><ul><li>打开vscode，打开控制台，切换到问题 tab 欧了，开始尝试 ts 吧</li></ul> <h2 id="⭐️基础类型"><a href="#⭐️基础类型" class="header-anchor">#</a> ⭐️基础类型</h2> <h4 id="boolean"><a href="#boolean" class="header-anchor">#</a> boolean</h4> <div class="language- extra-class"><pre class="language-text"><code>let isDone: boolean = false;
// 使用构造函数 Boolean 创造的对象不是布尔值
</code></pre></div><h4 id="null-undefined"><a href="#null-undefined" class="header-anchor">#</a> null &amp; undefined</h4> <ul><li>null &amp; undefined是所有类型的子类型</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let u: undefined = undefined;
let n: null = null;
let num: number = undefined;
let u: undefined;
let num: number = u;
</code></pre></div><h4 id="void-类型"><a href="#void-类型" class="header-anchor">#</a> void 类型</h4> <ul><li>void类型不能赋值给 number</li> <li>一般表示函数没有返回值。用在变量上没有什么卵用。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function warnUser(): void {
    console.log(&quot;This is my warning message&quot;);
}
let a: void = undefined
let a: void = 'undefined' // 报错，这是字符串
</code></pre></div><ul><li>跟它相似的类型还有undefined 和 null 在不开启严格空检查的情况下 --strictNullChecks，他们可以赋值给所有已经定义过***其他类型***的变量。 也就是说他们是所有类型的子类型</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let a: undefined = undefined
let a: null = null
</code></pre></div><h4 id="数字-number"><a href="#数字-number" class="header-anchor">#</a> 数字 number</h4> <ul><li>TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。支持十进制和十六进制字面量二进制和八进制字面量。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
// ES6 中的二进制表示法
let binaryLiteral: number = 0b1010;
// ES6 中的八进制表示法
let octalLiteral: number = 0o744;
let notANumber: number = NaN;
let infinityNumber: number = Infinity;
</code></pre></div><h4 id="字符串-string"><a href="#字符串-string" class="header-anchor">#</a> 字符串 string</h4> <ul><li>单双引'' &quot;&quot;，模板字符的都被视为字符串</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let str:string = ''
</code></pre></div><h2 id="⭐️数组类型"><a href="#⭐️数组类型" class="header-anchor">#</a> ⭐️数组类型</h2> <ul><li>有多种声明数组的方式,最简单的方法是使用类型 + []来表示数组：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const arr: number[] = [1,2,3]
const arr2: string[] = ['1','2']
</code></pre></div><ul><li>数组泛型定义方式</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const arr2: Array&lt;number&gt; = [1,2,3,3]
const arr2: Array&lt;string&gt; = [1,2,3,3]
</code></pre></div><ul><li>接口表示数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>interface NumArr {
    [index: number]: number;
}
let numArr: NumArr = [1,2,3];
</code></pre></div><ul><li>any 类型数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let list:any[] = [1,&quot;z&quot;,{}]
</code></pre></div><ul><li>元组类型声明</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 表示一个确定数组长度和类型的写法
const arr:[string,number] = ['2',3]
</code></pre></div><ul><li><p>类数组就是伪数组的定义</p></li> <li><p>官方已给了各自的定义接口 Arguments, NodeList, HTMLCollection</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function sum() {
    let args: IArguments = arguments;
}
</code></pre></div><ul><li><p>枚举 enum</p> <ul><li>js中没有这类型，仿照强类型语言来的。值只能为数字，不定义默认值得情况为从0开始。</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green;
// c = 1

enum Number {one = 10, two}
let c: Number = Number.two;
// c = 11
</code></pre></div><h2 id="⭐️any-类型-任意值"><a href="#⭐️any-类型-任意值" class="header-anchor">#</a> ⭐️any 类型(任意值)</h2> <ul><li>指代所有的类型</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let a: any = '123'
let a = 123; // 不声明默认 any
</code></pre></div><ul><li>never
<ul><li>表示永远不存在的值,一般会用来写抛出异常或推断为返回值为never的函数。（比如return一个其他的never类型）</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function error(message: string): never {
    throw new Error(message);
}
error('a')
</code></pre></div><ul><li>object 类型
<ul><li>非简单类型 也就是除number，string，boolean，symbol，null或undefined之外的类型。</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function create(o: object | null): void{
  console.log(o);
};
create({ prop: 0 }); // OK
create(null); // OK
create([]); // OK
create('a'); // error
</code></pre></div><h2 id="⭐️interface-接口"><a href="#⭐️interface-接口" class="header-anchor">#</a> ⭐️interface 接口</h2> <ul><li>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。
<ul><li>对对象的描述,接口一般首字母大写。赋值的时候，变量必须和接口保持一致。</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};
</code></pre></div><h4 id="可选属性"><a href="#可选属性" class="header-anchor">#</a> 可选属性</h4> <ul><li>不想完全匹配某个接口,通过?表示这个属性是可选的,仍然不允许添加未定义的属性</li></ul> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};
</code></pre></div><h4 id="任意属性"><a href="#任意属性" class="header-anchor">#</a> 任意属性</h4> <ul><li>让接口允许添加任意的属性值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>[propName: string]: any;

interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};
</code></pre></div><ul><li>一旦定义了任意属性， 那么确定属性和?可选属性都必须是任意属性的子集</li></ul> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}

let p:Person = {
    name: 'zzc',
    age: 12, // error ， 定义了 propName 必须将值设定为 string 类型
    gender: 'male' ,
}
</code></pre></div><h4 id="只读属性-readonly"><a href="#只读属性-readonly" class="header-anchor">#</a> 只读属性 readonly</h4> <ul><li>只读属性 readonly相当于是常量了，初次赋值后不能重新赋值 做为变量使用的话用 const，若做为属性则使用readonly。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>interface demo {
  readonly a: string; // readonly定以后不能改值
  b: number
}
let obj: demo = {
  a: 'ss',
  b: 1
}
obj.a = 'aa' // error
obj.b = 2 // success
</code></pre></div><ul><li>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</li></ul> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
    readonly id: number;
}
const tom: Person = {} // error
tom.id = 1 // error,
</code></pre></div><ul><li>会报两次错，第一个是因为指定了 id，但没有给 id 赋值, 第二个错是给只读属性id赋值了</li></ul> <h4 id="readonlyarray"><a href="#readonlyarray" class="header-anchor">#</a> ReadonlyArray</h4> <ul><li>通过ReadonlyArray定义的数组，再也无法改变了。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = [1,2,3];
a[0] = 10 // success
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // 注意！ 将readonly的值赋值给一个可变得数组也是不行的。
a = ro as Array&lt;any&gt; // 但是可以用断言重写
</code></pre></div><h2 id="⭐️函数类型"><a href="#⭐️函数类型" class="header-anchor">#</a> ⭐️函数类型</h2> <ul><li><p>常见的函数声明方式有： 函数声明 &amp; 函数表达式</p></li> <li><p>用 ts 定义函数要考虑它的输入和输出</p> <ul><li>函数声明方式定义</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function sum(a:number,b:number):number{
    return a+b
}
// 形参和实参数量要一致
sum(1) // error
sum(1,2) //3
sum(1,2,3) // error
</code></pre></div><ul><li>函数表达式定义</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 方式 1
let sum = function(a:number,b:number):number {
    return a + b;
}
// 方式二
let sum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
    return x + y;
};
</code></pre></div><ul><li><p>方式一中只对等号右侧的匿名函数定义了类型，左边是ts通过类型推论定义出来的</p></li> <li><p>方式二才是给 sum 定义类型，**其中的 =&gt; 不是 es6的 =&gt; ** ,它用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p></li> <li><p>因为和 es6箭头函数可能造成混淆，最好用方式一；</p></li></ul> <h4 id="可选参数"><a href="#可选参数" class="header-anchor">#</a> 可选参数</h4> <ul><li>通过?给函数定义可选参数</li> <li>可选参数后面不允许再出现必须参数了</li> <li>如果给参数添加了默认值，ts 会自动识别为可选，且不受上一条规则的限制。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function sum(a:number,b?:number){}
function sum(a?:number,b:number){} // error
function sum(a:number = 1,b:number){} // 默认值，识别为可选，且不报错
</code></pre></div><h4 id="rest"><a href="#rest" class="header-anchor">#</a> ...rest</h4> <ul><li><p>使用…rest获取剩余参数，使用数组类型去定义它</p></li> <li><p>剩余参数必须是函数的最后一个参数</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function (a, ...items:any[]){}
function (...items:any[], a){} // error
</code></pre></div><h4 id="函数的重载"><a href="#函数的重载" class="header-anchor">#</a> 函数的重载</h4> <ul><li><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p></li> <li><p>可以重复定义一个函数的类型</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function say(somthing:string):string;
function say(somthing:number):string;
// 以上是函数定义

// 以下是函数实现
function say(somthing:string|number):string|number {
    return somthing
}
</code></pre></div><ul><li>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</li></ul> <h2 id="⭐️类型断言"><a href="#⭐️类型断言" class="header-anchor">#</a> ⭐️类型断言</h2> <ul><li><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p></li> <li><p>断定这个变量的类型是啥</p></li> <li><p>类型断言不是类型转换</p></li> <li><p>两种写法</p></li> <li><p>&lt;类型&gt;值 or 值 as 类型</p></li> <li><p>如果在 tsx 语法中使用，必须用 as</p></li> <li><p>例子</p></li> <li><p>联合类型可以指定一个变量为多种类型，此变量只能访问类型们的共有方法。</p></li> <li><p>但一些情况下我们必须使用某一类型的方法或属性时，就可以用断言</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function say(something:number|string):void{
    alert(something.length) // 联合类型，报错
}
// ==&gt; 使用断言, 在变量前加上 &lt;类型&gt;
function say(something:number|string):void{
    alert( (&lt;string&gt;something).length ) // success
}
</code></pre></div><ul><li>断言成一个联合类型中不存在的类型是不允许的</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function say(something:number|string):void{
    alert(&lt;boolean&gt;something.length) // 联合类型没有 boolean ,error
}
</code></pre></div><h2 id="⭐️declare-声明"><a href="#⭐️declare-声明" class="header-anchor">#</a> ⭐️declare 声明</h2> <ul><li><p>第三方库会暴露出一个变量，让我们在项目中直接使用。</p></li> <li><p>但是 ts 编译时不知道这是啥，编译无法通过。</p></li> <li><p>此时我们就要用 declare var 声明语句来定义他的类型</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code> // 比如 jquery
$('div') // ERROR: Cannot find name 'jQuery'.

// ==&gt; 使用 declare var 第三方库变量: (参数: string) =&gt; 返回类型
declare var $: (selector: string) =&gt; any;

$('#foo'); // success
</code></pre></div><ul><li>declare var 并不是真正的声明一个变量，编译完会删除，仅仅是定义类型。</li></ul> <h4 id="声明文件"><a href="#声明文件" class="header-anchor">#</a> 声明文件</h4> <ul><li><p>通常我们会把声明语句放到一个单独的文件（*.d.ts）中，这就是声明文件</p></li> <li><p>声明文件必需以 .d.ts 为后缀</p></li> <li><p>假如仍然无法解析，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// src/jQuery.d.ts

declare var jQuery: (selector: string) =&gt; any;
</code></pre></div><ul><li>这只是非模块化项目中使用的例子</li></ul> <h4 id="第三方声明文件"><a href="#第三方声明文件" class="header-anchor">#</a> 第三方声明文件</h4> <ul><li><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p></li> <li><p>我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。</p></li> <li><p>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm i @types/jquery -D
</code></pre></div><ul><li>可以在这个页面搜索你需要的声明文件。</li></ul> <h4 id="自定义声明文件"><a href="#自定义声明文件" class="header-anchor">#</a> 自定义声明文件</h4> <ul><li><p>声明文件有以下方法</p> <ul><li>全局变量：通过 <script></script></li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontEnd/es6.html" class="prev">ES6</a></span> <span class="next"><a href="/frontEnd/ts.html">TypeScript (进阶)</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.27194c62.js" defer></script><script src="/assets/js/2.660d2c2d.js" defer></script><script src="/assets/js/14.e7071a84.js" defer></script>
  </body>
</html>

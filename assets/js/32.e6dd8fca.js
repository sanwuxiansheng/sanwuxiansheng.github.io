(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{231:function(t,n,e){"use strict";e.r(n);var a=e(0),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"自己封装的一些方法和函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自己封装的一些方法和函数"}},[t._v("#")]),t._v(" 自己封装的一些方法和函数")]),t._v(" "),e("h2",{attrs:{id:"函数节流和防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数节流和防抖"}},[t._v("#")]),t._v(" 函数节流和防抖")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("单位时间内，减少函数的调用次数。 提升性能")])]),t._v(" "),e("li",[e("p",[t._v("节流函数：单位时间内函数只调用一次，第一次")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\tfunction throttle(fn, time) {\n\t\tlet startTime = 0;\n\t\treturn function () {\n\t\t  const endTime = Date.now();\n\t\t  if (endTime - startTime >= time) {\n\t\t\tfn.apply(this, arguments);  // [[123], 2, 3]\n\t\t  }\n\t\t}\n\t}\n")])])])]),t._v(" "),e("li",[e("p",[t._v("防抖函数：单位时间内函数只调用一次，最后一次")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\tfunction debounce(fn, time) {\n\t\tlet timerId = null;\n\t\treturn function () {\n\t\t\tclearTimeout(timerId);\n\t\t\tconst _self = this;\n\t\t\tconst args = arguments;\n\t\t\ttimerId = setTimeout(function () {\n\t\t\t\tfn.apply(_self, args);\n\t\t\t}, time)\n\t\t}\n\t\n\t}\n")])])])])]),t._v(" "),e("h2",{attrs:{id:"数组快排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组快排"}},[t._v("#")]),t._v(" 数组快排")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.prototype.quickSort = function () {\n\n  // 生成新数组\n  const arr = [...this];\n  // 判断数组长度，大于1才参与排序\n  let length = arr.length;\n  if (length < 2) return arr;\n  // 找到基准值（简单取中间值）\n  const pivotIndex = Math.floor(length / 2);\n  // 基准值不参与排序， 所以从数组提取来\n  const pivot = arr.splice(pivotIndex, 1);\n  length--;\n\n  const left = [];\n  const right = [];\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n    if (item < pivot) {\n      left.push(item);\n    } else {\n      right.push(item);\n    }\n  }\n  return left.quickSort().concat(pivot, right.quickSort());\n};\n\nconst arr = [2, 8, 4, 7, 5, 2, 3, 6, 1];\n\nconsole.log(arr.quickSort());\nconsole.log(arr);\n")])])]),e("h2",{attrs:{id:"用js实现instanceof-instanceof判断传入的参数a是否参数b的类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用js实现instanceof-instanceof判断传入的参数a是否参数b的类型"}},[t._v("#")]),t._v(" 用js实现instanceof(instanceof判断传入的参数A是否参数B的类型)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function myInstanceof (A, B) {\n  // 检查B必须是一个函数类型。 只有函数有prototype\n  if (typeof B !== 'function') {\n    throw new Error ('B is not a function');\n  };\n  // 如果A不是对象(对象包含普通对象、函数、数组)，就不用检查，直接返回false。\n  if (typeof A !== ('object' || 'function')) {\n    return false;\n  };\n  let a = A.__proto__;\n  const b = B.prototype;\n  while (a) {\n    if ( a === b ) {\n      return true;\n    } else {\n      a = a.__proto__;\n    }\n  }\n  return false;\n};\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);
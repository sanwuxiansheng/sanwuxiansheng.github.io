(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{221:function(t,e,v){"use strict";v.r(e);var r=v(0),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"个人面试总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#个人面试总结"}},[t._v("#")]),t._v(" 个人面试总结")]),t._v(" "),v("h4",{attrs:{id:"一、对于mvvm的理解？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、对于mvvm的理解？"}},[t._v("#")]),t._v(" 一、对于MVVM的理解？")]),t._v(" "),v("ol",[v("li",[t._v("MVVM 是 Model-View-ViewModel 的缩写。")]),t._v(" "),v("li",[t._v("Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。")]),t._v(" "),v("li",[t._v("View 代表UI 组件，它负责将数据模型转化成UI 展现出来。")]),t._v(" "),v("li",[t._v("ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。")]),t._v(" "),v("li",[t._v("在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。")]),t._v(" "),v("li",[t._v("ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理")])]),t._v(" "),v("h4",{attrs:{id:"mvvm的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvvm的优缺点"}},[t._v("#")]),t._v(" MVVM的优缺点?")]),t._v(" "),v("p",[t._v("优点:")]),t._v(" "),v("ul",[v("li",[t._v('分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的"View"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑')]),t._v(" "),v("li",[t._v("提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码")]),t._v(" "),v("li",[t._v("自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放")])]),t._v(" "),v("p",[t._v("缺点:")]),t._v(" "),v("ul",[v("li",[t._v("Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存")]),t._v(" "),v("li",[t._v("对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高")])]),t._v(" "),v("h4",{attrs:{id:"vue实现数据双向绑定的原理：object-defineproperty（）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue实现数据双向绑定的原理：object-defineproperty（）"}},[t._v("#")]),t._v(" Vue实现数据双向绑定的原理：Object.defineProperty（）")]),t._v(" "),v("ol",[v("li",[t._v("vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过**Object.defineProperty（）**来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。")]),t._v(" "),v("li",[t._v("vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。")])]),t._v(" "),v("h4",{attrs:{id:"vue的路由实现：hash模式-和-history模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的路由实现：hash模式-和-history模式"}},[t._v("#")]),t._v(" Vue的路由实现：hash模式 和 history模式")]),t._v(" "),v("ol",[v("li",[t._v("**hash模式：**在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；")]),t._v(" "),v("li",[t._v("特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。")]),t._v(" "),v("li",[t._v("hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。")]),t._v(" "),v("li",[t._v("**history模式：**history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。")]),t._v(" "),v("li",[t._v("history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。")])]),t._v(" "),v("h4",{attrs:{id:"computed和watch有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch有什么区别"}},[t._v("#")]),t._v(" computed和watch有什么区别?")]),t._v(" "),v("ul",[v("li",[t._v("computed:\n"),v("ul",[v("li",[t._v("computed是计算属性,也就是计算值,它更多用于计算值的场景")]),t._v(" "),v("li",[t._v("computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算")]),t._v(" "),v("li",[t._v("computed适用于计算比较消耗性能的计算场景")])])]),t._v(" "),v("li",[t._v("watch:\n"),v("ul",[v("li",[t._v("更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作")]),t._v(" "),v("li",[t._v("无缓存性，页面重新渲染时值不变化也会执行")])])]),t._v(" "),v("li",[t._v("小结:\n"),v("ul",[v("li",[t._v("当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed")]),t._v(" "),v("li",[t._v("如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化")])])])]),t._v(" "),v("h4",{attrs:{id:"vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[t._v("#")]),t._v(" Vue生命周期")]),t._v(" "),v("ul",[v("li",[t._v("创建前后 beforeCreate/created")]),t._v(" "),v("li",[t._v("在beforeCreate 阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象有了，el还没有。")]),t._v(" "),v("li",[t._v("载入前后 beforeMount/mounted")]),t._v(" "),v("li",[t._v("在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前未虚拟的DOM节点，data尚未替换。")]),t._v(" "),v("li",[t._v("在mounted阶段，vue实例挂载完成，data成功渲染。")]),t._v(" "),v("li",[t._v("更新前后 beforeUpdate/updated")]),t._v(" "),v("li",[t._v("当data变化时，会触发beforeUpdate和updated方法。这两个不常用，不推荐使用。")]),t._v(" "),v("li",[t._v("销毁前后beforeDestory/destoryed")]),t._v(" "),v("li",[t._v("beforeDestory是在vue实例销毁前触发，一般在这里要通过removeEventListener解除手动绑定的事件。实例销毁后，触发的destroyed。")])]),t._v(" "),v("h4",{attrs:{id:"_4-mvvm和mvc的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvvm和mvc的区别"}},[t._v("#")]),t._v(" 4.mvvm和mvc的区别")]),t._v(" "),v("pre",[v("code",[t._v("首先可以先说一下view和model\t\t\t\t\n\tview是指用户的视图\t\t\t\t\t\n\tmodel是指本地数据和数据库中的数据\t\t\t\t\t\t\t\t\t\n基本来说我们的产品都是通过接口获取数据，处理数据后进行视图渲染，也可以获取视图中用户输入，然后通过接口写入到数据库中\n传统的mvc架构，是通过控制器更新模型，视图从模型中获取数据进行渲染，当用户有输入时，通过控制器更新模型，在通知视图进行更新\t\t\t\t\t\t\n\t那么，mvc框架的弊端就是控制器承担了更多的责任，当我们的项目日渐成熟复杂时，控制器中的代码会越来越臃肿，不利于后期维护\t\t\t\t\t\n在MVVM架构中，引入了viewModel的思想，viewModel只在乎数据和业务的处理，不在乎view如何处理数据，那么这种情况下就可以将view和Model单独分离出来，\t\t\t\t\t\t\n\t一方的改变并不一定会改变另一方，并且可以将可复用的逻辑放入viewModel中，可用多个view复用这个viewModel。\t\n")])]),t._v(" "),v("h4",{attrs:{id:"_5-组件化开发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-组件化开发"}},[t._v("#")]),t._v(" 5.组件化开发")]),t._v(" "),v("pre",[v("code",[t._v("组件化开发 =>有利于组件的复用,涉及到组件间的通信\n")])]),t._v(" "),v("h4",{attrs:{id:"_6-组件间的通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-组件间的通信方式"}},[t._v("#")]),t._v(" 6.组件间的通信方式")]),t._v(" "),v("pre",[v("code",[t._v("props(父组件传子组件)\nslot(通过作用域插槽 => 父组件传子组件)\n自定义事件(子组件传父组件)\n事件总线(通过原型链方法将Vue的实例对象绑定到其原型上 => 任意组件间通信)\nvuex(任意组件间通信)\npubsub(任意组件间通信)\nref()\nprovide/reject\n")])]),t._v(" "),v("h4",{attrs:{id:"_7-vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-vuex"}},[t._v("#")]),t._v(" 7. Vuex")]),t._v(" "),v("pre",[v("code",[t._v("用于集中式存储管理应用的所有组件的状态\nVuex 和单纯的全局对象是不同的:Vuex的状态存储都是响应式的,并且不能直接修改store中的状态\nVuex主要有5个核心概念\n\tstate => vuex管理的状态对象,是唯一的\n\tmutations => 包含多个直接更新state的状态的对象，包含同步代码\n\tactions =>包含多个间接更新state的状态的对象(通过通知mutations中对应的方法更新),包含异步代码,\n    getters => 包含多个计算属性的对象\n\tmodules => 包含多个module,每个module都可以配置对应的store对象,适用于多模块开发\n\t使用modules进行多模块开发,获取每个module的状态数据和之前的获取方式是由差别的,主要通过函数的返回值来获得\n")])]),t._v(" "),v("h4",{attrs:{id:"_8-vuex和redux的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-vuex和redux的区别"}},[t._v("#")]),t._v(" 8. vuex和redux的区别")]),t._v(" "),v("pre",[v("code",[t._v("从表面上来说，store注入和使用方式有一些区别\n 8.1.在vuex中，$store被直接注入到组件实例中，因此可以比较灵活的使用\n     使用dispatch和commit提交更新\n     通过mapState或者通过this.$store来读取数据\n在redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来\n8.2.vuex更加灵活一些，组件中既可以dispatch action 也可以commit updates，二redux中只能进行dispatch\n\n8.3.***原理上，redux使用不可变数据，每次都是新的state替换就得state\n           vuex数据是可变的，直接修改\n          redux在监测数据变化时，通过diff算法比较差异，\n           vuex和vue原理一样，通过getter/setter比较（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）\n    \n而这两点的区别，其实也是因为 React 和 Vue的设计理念上的区别。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框\n")])]),t._v(" "),v("h4",{attrs:{id:"_9-spa单页面应用开发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-spa单页面应用开发"}},[t._v("#")]),t._v(" 9.SPA单页面应用开发")]),t._v(" "),v("pre",[v("code",[t._v("主要通过router来实现\n路由分为编程式路由和声明式路由,在使用路由时,先要创建路由器,配置对应的路由对象,同时可以通过路由进行传参\n编程式路由的2个对象$router(读操作)和$route(写操作)\n\t主要通过$route()方法来实现\n路由传参的三种方式\n\t通过调用$router.push实现带参数跳转\n\t通过路由属性中的name来确定匹配的路由,通过params来传递参数\n\t使用path来匹配路由,然后通过query来传递参数\n获取路由传参的参数\n\t$route.query.id\n导航守卫:首先守卫是异步解析执行的,在守卫没有触发前都处于resolve状态,导航守卫分为全局守卫,路由守卫,组件守卫。\n\t每个守卫方法都接收三个参数\n\t\tto：即将要进入的目标路由对象\n        from:当前导航正要离开的路由\n        next:必须调用的方法,只有调用了才能进入下一个守卫\n\t\t\t所有守卫执行完毕进入comfired状态\n\t全局守卫\n    \troute.afterEnter((to,from,next) =>{})\n\t路由守卫\n    \troutes对用路由中设置\n        \tbeforeEnter((to,from,next) => {})\n\t组件守卫\n    \t路由组价内\n        \tbeforeRouteEnter(to,from,next){\n                // 在渲染组件的对应路由被confirm调用\n            }\n            beforeRouterUpdate(to,from,next){\n                // 当前路由改变,但是该组件被复用时调用\n            }\n            beforeRouteLeave(to,from,next){\n                // 导航离开该组件的对应用时调用\n            }\n")])]),t._v(" "),v("h4",{attrs:{id:"微信支付流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微信支付流程"}},[t._v("#")]),t._v(" 微信支付流程")]),t._v(" "),v("ul",[v("li",[t._v("wx.login获取用户临时登录凭证code，发送到后端服务器换取openId")]),t._v(" "),v("li",[t._v("在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器")]),t._v(" "),v("li",[t._v("服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)")]),t._v(" "),v("li",[t._v("小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付")])]),t._v(" "),v("h4",{attrs:{id:"一句话就能回答的面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一句话就能回答的面试题"}},[t._v("#")]),t._v(" 一句话就能回答的面试题")]),t._v(" "),v("ul",[v("li",[t._v("1.css只在当前组件起作用")]),t._v(" "),v("li",[t._v("答：在style标签中写入scoped即可 例如：")]),t._v(" "),v("li",[t._v("2.v-if 和 v-show 区别")]),t._v(" "),v("li",[t._v("答：v-if按照条件是否渲染，v-show是display的block或none；")]),t._v(" "),v("li",[t._v("3.router的区别")]),t._v(" "),v("li",[t._v("答：router是“路由实例”对象包括了路由的跳转方法，钩子函数等。")]),t._v(" "),v("li",[t._v("4.vue.js的两个核心是什么？")]),t._v(" "),v("li",[t._v("答：数据驱动、组件系统")]),t._v(" "),v("li",[t._v("5.vue几种常用的指令")]),t._v(" "),v("li",[t._v("答：v-for 、 v-if 、v-bind、v-on、v-show、v-else")]),t._v(" "),v("li",[t._v("6.vue常用的修饰符？")]),t._v(" "),v("li",[t._v("答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用")]),t._v(" "),v("li",[t._v("7.v-on 可以绑定多个方法吗？")]),t._v(" "),v("li",[t._v("答：可以")]),t._v(" "),v("li",[t._v("8.vue中 key 值的作用？")]),t._v(" "),v("li",[t._v("答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。")]),t._v(" "),v("li",[t._v("9.什么是vue的计算属性？")]),t._v(" "),v("li",[t._v("答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。")]),t._v(" "),v("li",[t._v("10.vue等单页面应用及其优缺点")]),t._v(" "),v("li",[t._v("答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。")]),t._v(" "),v("li",[t._v("缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。")])]),t._v(" "),v("hr"),t._v(" "),v("h4",{attrs:{id:"存储相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储相关"}},[t._v("#")]),t._v(" 存储相关")]),t._v(" "),v("pre",[v("code",[t._v("1.cookie\n2.session\n3.WebStorage\n\t3.1localStorage\n    \tLocalStorage是浏览器本地持久化存储技术，也叫永久存储\n        特点:持久存储:数据会一直保存,除非删除\n    3.2sessionStorage\n    \tSessionStorage是浏览器本地临时存储技术，也叫会话存储\n        特点:会话存储:当会话开始时会一会保留,直到会话结束会自动删除\n4.缓存策略\n")])]),t._v(" "),v("h4",{attrs:{id:"谈谈promise"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#谈谈promise"}},[t._v("#")]),t._v(" 谈谈Promise")]),t._v(" "),v("ul",[v("li",[t._v("一个异步编程解决方案之一，解决回调函数嵌套回调函数（回调地狱）问题")]),t._v(" "),v("li",[t._v("内部有三种状态：\n"),v("ul",[v("li",[t._v("初始化 pending")]),t._v(" "),v("li",[t._v("成功 resolved / fullfilled")]),t._v(" "),v("li",[t._v("失败 rejected")]),t._v(" "),v("li",[t._v("有且只有其中一种状态")]),t._v(" "),v("li",[t._v("只能由初始化变成成功/失败，不能成功 -> 失败")])])]),t._v(" "),v("li",[t._v("使用：\n"),v("ul",[v("li",[t._v("new Promise((resolve, reject) => {})\n"),v("ul",[v("li",[t._v("在回调函数里面写异步代码")]),t._v(" "),v("li",[t._v("resolve 将promise对象初始化状态改为成功状态")]),t._v(" "),v("li",[t._v("reject 将promise对象初始化状态改为失败状态")])])]),t._v(" "),v("li",[t._v("Promise.resolve() 创建成功状态的promise对象")]),t._v(" "),v("li",[t._v("Promise.reject() 创建失败状态的promise对象")]),t._v(" "),v("li",[t._v("Promise.all([promise1, promise2..…])\n"),v("ul",[v("li",[t._v("当数组中所有promise对象状态都变成成功状态时，返回的promise对象就是成功状态")]),t._v(" "),v("li",[t._v("一旦有一个失败，返回的promise对象就是失败状态")])])])])]),t._v(" "),v("li",[t._v("generator\n"),v("ul",[v("li",[t._v("一个异步编程解决方案之一，解决回调函数嵌套回调函数（回调地狱）问题")]),t._v(" "),v("li",[t._v("惰性函数，不能自己执行")]),t._v(" "),v("li",[t._v("通过function* fn() {}定义函数。 函数内部有yield关键字，用来暂停")]),t._v(" "),v("li",[t._v("执行generator函数返回一个iterator对象（函数体代码并不会执行）。")]),t._v(" "),v("li",[t._v("当调用iterator对象.next()才会执行")]),t._v(" "),v("li",[t._v("generator用的较少，一般不用")])])]),t._v(" "),v("li",[t._v("async\n"),v("ul",[v("li",[t._v("一个异步编程解决方案之一，解决回调函数嵌套回调函数（回调地狱）问题")]),t._v(" "),v("li",[t._v("真正异步解决方案。")]),t._v(" "),v("li",[t._v("本质上是generator函数的语法糖")]),t._v(" "),v("li",[t._v("用async取代*，定义函数。 用await取代yield来暂停函数执行")]),t._v(" "),v("li",[t._v("await后面只能跟promise对象（只会等待promise），当promise对象为成功状态时会继续执行")]),t._v(" "),v("li",[t._v("执行async函数返回值也是promise对象")])])]),t._v(" "),v("li",[t._v("当遇到异步代码时，使用以上解决方式解决")])]),t._v(" "),v("h4",{attrs:{id:"事件机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件机制"}},[t._v("#")]),t._v(" 事件机制")]),t._v(" "),v("pre",[v("code",[t._v("绑定事件：\n  element.addEventListener('click',function (event) {},false) -- 有捕获和冒泡\n  IE:element.attachEvent('onclick', function () {})   -- 只有冒泡\n解绑事件：\n  element.removeEventListener('click', fnName, false)\n  IE:element.detachEvent('onclick', fnName)\n事件对象：\n  event\n  IE:window.event\n阻止事件默认行为：\n  ev.preventDefault();//DOM0或DOM2\n  return false;//DOM0\n  IE:ev.returnValue = false;\n阻止事件传播：\n  ev.stopPropagation()\n  ev.cancelBubble = true\n")])]),t._v(" "),v("hr"),t._v(" "),v("h4",{attrs:{id:"_1、请谈谈原型。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、请谈谈原型。"}},[t._v("#")]),t._v(" 1、请谈谈原型。")]),t._v(" "),v("ul",[v("li",[t._v("原型是两个原型属性：prototype和__proto__")]),t._v(" "),v("li",[t._v("显示原型属性：所有函数都有显示原型属性。它的值是一个对象，原型对象。（constructor：函数本身  "),v("strong",[t._v("proto")]),t._v(": Object.prototype (例外：Object.prototype."),v("strong",[t._v("proto")]),t._v(" === null)）")]),t._v(" "),v("li",[t._v("隐式原型属性：所有对象都有隐式原型属性。它的值是其构造函数的显示原型指向的原型对象。")]),t._v(" "),v("li",[t._v("原型链：多个隐式原型属性组成链状结构。\n作用：查找对象上属性/方法的规则\n规则：先找自身 -- 再找原型链上的东西 -- Object.prototype."),v("strong",[t._v("proto")]),t._v(" -- 返回值undefined")]),t._v(" "),v("li",[t._v("所有函数都是new Function产生的。函数."),v("strong",[t._v("proto")]),t._v(" === Function.prototype  (包括Function)")]),t._v(" "),v("li",[t._v("所有数组都是new Array产生的。数组."),v("strong",[t._v("proto")]),t._v(" === Array.prototype")]),t._v(" "),v("li",[t._v("普通对象（不是你new的）都是new Object产生的。对象."),v("strong",[t._v("proto")]),t._v(" === Object.prototype")])]),t._v(" "),v("h4",{attrs:{id:"_2、预解析、预处理做了什么事情？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、预解析、预处理做了什么事情？"}},[t._v("#")]),t._v(" 2、预解析、预处理做了什么事情？")]),t._v(" "),v("ul",[v("li",[t._v("预解析、预处理: js引擎在执行代码之前做的事")]),t._v(" "),v("li",[t._v("首先对代码进行分类：全局代码、函数代码")]),t._v(" "),v("li",[t._v("全局代码：\n"),v("ul",[v("li",[t._v("首先先创建全局执行上下文对象 - window")]),t._v(" "),v("li",[t._v("将var声明的变量添加为window的属性，值为undefined")]),t._v(" "),v("li",[t._v("将function声明的函数添加为window方法，值为函数本身")]),t._v(" "),v("li",[t._v("将this指向window")]),t._v(" "),v("li",[t._v("就开始执行全局代码")])])]),t._v(" "),v("li",[t._v("函数代码：\n"),v("ul",[v("li",[t._v("首先创建函数执行上下文对象")]),t._v(" "),v("li",[t._v("将var声明的变量添加为函数执行上下文对象的属性，值为undefined")]),t._v(" "),v("li",[t._v("将function声明的函数添加为函数执行上下文对象的方法，值为函数本身")]),t._v(" "),v("li",[t._v("将形参赋值实参，添加为函数执行上下文对象的属性")]),t._v(" "),v("li",[t._v("将arguments赋值实参，添加为函数执行上下文对象的属性")]),t._v(" "),v("li",[t._v("将this指向调用函数的对象")]),t._v(" "),v("li",[t._v("就开始执行函数代码")]),t._v(" "),v("li",[t._v("执行完函数代码，就会销毁函数执行上下文对象")])])])]),t._v(" "),v("h4",{attrs:{id:"_3、作用域和作用域链是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、作用域和作用域链是什么？"}},[t._v("#")]),t._v(" 3、作用域和作用域链是什么？")]),t._v(" "),v("ul",[v("li",[t._v("作用域：一个代码块的区域。")]),t._v(" "),v("li",[t._v("静态的：在函数定义的时候就确定，和调用没关系")]),t._v(" "),v("li",[t._v("作用域链：多个上下级关系的作用域组成链。\n"),v("ul",[v("li",[t._v("作用：用来查找变量的。（自身 -- 上一个作用域 -- 最终全局作用域 -- 报错 xx is not defined）")])])])]),t._v(" "),v("h4",{attrs:{id:"_4、闭包是什么？如何产生的？闭包的作用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、闭包是什么？如何产生的？闭包的作用？"}},[t._v("#")]),t._v(" 4、闭包是什么？如何产生的？闭包的作用？")]),t._v(" "),v("ul",[v("li",[t._v("闭包: 通过chrome工具调试查看，闭包是一个包含被引用局部变量的closure“对象”，这个对象存在嵌套的内部函数中（一个包含被引用局部变量的“对象”）")]),t._v(" "),v("li",[t._v("如何产生的：\n"),v("ol",[v("li",[t._v("函数嵌套")]),t._v(" "),v("li",[t._v("内部函数引用外部函数局部变量")]),t._v(" "),v("li",[t._v("执行外部函数")])])]),t._v(" "),v("li",[t._v("作用：\n"),v("ol",[v("li",[t._v("延长局部变量的生命周期")]),t._v(" "),v("li",[t._v("让函数外面操作（读/写）函数内部的数据")])])])]),t._v(" "),v("h4",{attrs:{id:"_1、-浏览器渲染原理（浏览器是如何渲染的？）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、-浏览器渲染原理（浏览器是如何渲染的？）"}},[t._v("#")]),t._v(" 1、 浏览器渲染原理（浏览器是如何渲染的？）")]),t._v(" "),v("ul",[v("li",[t._v("遇到html标记，调用html解析器解析成DOM树")]),t._v(" "),v("li",[t._v("遇到CSS标记，调用css解析器解析CSSOM树")]),t._v(" "),v("li",[t._v("遇到js标记,调用js引擎解析其中的代码\n"),v("ul",[v("li",[t._v("可能会修改html、css")]),t._v(" "),v("li",[t._v("重新调用html、CSS解析器重新解析，分别构建dom树、cssom树")])])]),t._v(" "),v("li",[t._v("将DOM树和CSSOM树合并成render树")]),t._v(" "),v("li",[t._v("布局（计算元素大小和位置）")]),t._v(" "),v("li",[t._v("渲染（颜色）")])]),t._v(" "),v("h4",{attrs:{id:"重排重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重排重绘"}},[t._v("#")]),t._v(" 重排重绘")]),t._v(" "),v("ol",[v("li",[t._v("重绘(Repaint)")])]),t._v(" "),v("ul",[v("li",[t._v("重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。")]),t._v(" "),v("li",[t._v("浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。")]),t._v(" "),v("li",[t._v("重绘不会带来重新布局，所以并不一定伴随重排。")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("重排(Reflow 回流)")])]),t._v(" "),v("ul",[v("li",[t._v("渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排")]),t._v(" "),v("li",[t._v('"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。')]),t._v(" "),v("li",[t._v('但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。')])]),t._v(" "),v("h4",{attrs:{id:"_4、-谈谈箭头函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、-谈谈箭头函数"}},[t._v("#")]),t._v(" 4、 谈谈箭头函数")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("作用: 定义匿名函数")])]),t._v(" "),v("li",[v("p",[t._v("基本语法:")]),t._v(" "),v("ul",[v("li",[t._v("没有参数: () => console.log('xxxx')")]),t._v(" "),v("li",[t._v("一个参数: i => i+2")]),t._v(" "),v("li",[t._v("大于一个参数: (i,j) => i+j")]),t._v(" "),v("li",[t._v("函数体不用大括号: 默认返回结果")]),t._v(" "),v("li",[t._v("函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回")])])]),t._v(" "),v("li",[v("p",[t._v("使用场景: 多用来定义回调函数")])]),t._v(" "),v("li",[v("p",[t._v("箭头函数的特点：")]),t._v(" "),v("ul",[v("li",[t._v("简洁")]),t._v(" "),v("li",[t._v("箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this")]),t._v(" "),v("li",[t._v("扩展理解：\n"),v("ul",[v("li",[t._v("箭头函数的this看外层的是否有函数，")]),t._v(" "),v("li",[t._v("如果有，外层函数的this就是内部箭头函数的this，")]),t._v(" "),v("li",[t._v("如果没有，则this是window。")])])])])])]),t._v(" "),v("h4",{attrs:{id:"_5、-总结this指向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、-总结this指向"}},[t._v("#")]),t._v(" 5、 总结this指向")]),t._v(" "),v("h6",{attrs:{id:"普通函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#普通函数"}},[t._v("#")]),t._v(" 普通函数")]),t._v(" "),v("ul",[v("li",[t._v("普通函数直接调用 window")]),t._v(" "),v("li",[t._v("普通函数obj.fn()  obj")]),t._v(" "),v("li",[t._v("fn.call/apply(obj)  obj")]),t._v(" "),v("li",[t._v("new fn() 实例对象")]),t._v(" "),v("li",[t._v("箭头函数this指向：离它最近的一层，包裹着它的函数的this指向一致，如果没有函数包裹就是window")])]),t._v(" "),v("h6",{attrs:{id:"回调函数this："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回调函数this："}},[t._v("#")]),t._v(" 回调函数this：")]),t._v(" "),v("ul",[v("li",[t._v("setTimeout  window")]),t._v(" "),v("li",[t._v("事件的回调函数 绑定事件的dom元素")]),t._v(" "),v("li",[t._v("使用了严格模式：自定义函数的this如果之前指向window，现在指向undefined\n######浏览器缓存机制\n通常浏览器缓存策略分为两种：强缓存和协商缓存")])]),t._v(" "),v("p",[t._v("基本原理\n浏览器在加载资源时，根据请求头的Expires 和 cache-control判断是否命中强缓存，如果命中则直接从缓存读取资源，不会向服务器发起请求。\n如果强缓存没有命中，浏览器一定会向服务器发起请求，通过last-modefied 和Etag去判断资源是否命中协商缓存，如果命中代表资源没有更新，服务器会返回304，读取缓存中的资源，如果没有命中，则代表资源有更新，服务器会返回200，从服务器加载资源。\n强缓存和协商缓存的异同\n同： 如果两种缓存方式都未命中，则都需要从服务端加载资源\n异：强缓存命中不会向服务器发起请求，协商缓存需要向服务器发起请求\n强缓存\n强缓存通过Expires 和 Cache-Control 两种响应头实现。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Expires\nExpires: Wed, 22 Oct 2018 08:41:00 GMT\nExpires 出现于 HTTP / 1.0 ，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且受限于本地时间，如果修改了本地事件，如果修改了本地时间，可能造成缓存失效。")])]),t._v(" "),v("li",[v("p",[t._v("Cache-Control\nCache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间。")])])]),t._v(" "),v("p",[t._v("Cache-Control: max-age=315360000\n协商缓存\n协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】来管理的。")]),t._v(" "),v("ol",[v("li",[t._v("Last-Modefied & If-Modified-Since\nLast-Modefied代表服务器端文件的最后修改时间，当浏览器发起请求时，会向服务端发送If-modefied-Since报头，询问在Last-Modefied之后有没有被修改过。如果没有修改过，则返回304使用缓存，如果修改过，则向服务器请求资源，返回200。")])]),t._v(" "),v("p",[t._v("但是如果本地打开缓存文件，会导致Last-Modefied被修改，所以在 HTTP/1.1中引入 Etag.")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("Etag & & If-None-Match\nEtag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。当发送请求是If-None-Match会将上次的Etag发送给服务器进行判断是否有更新，如果有更新，则会请求新的资源。")])]),t._v(" "),v("p",[t._v("ETag的优先级比Last-Modified更高")]),t._v(" "),v("p",[t._v("具体为什么要用ETag，主要出于下面几种情况考虑：")]),t._v(" "),v("p",[t._v("一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；\n某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\n某些服务器不能精确的得到文件的最后修改时间。")]),t._v(" "),v("h6",{attrs:{id:"数组快排"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组快排"}},[t._v("#")]),t._v(" 数组快排")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("Array.prototype.quickSort = function () {\n\n  // 生成新数组\n  const arr = [...this];\n  // 判断数组长度，大于1才参与排序\n  let length = arr.length;\n  if (length < 2) return arr;\n  // 找到基准值（简单取中间值）\n  const pivotIndex = Math.floor(length / 2);\n  // 基准值不参与排序， 所以从数组提取来\n  const pivot = arr.splice(pivotIndex, 1);\n  length--;\n\n  const left = [];\n  const right = [];\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n    if (item < pivot) {\n      left.push(item);\n    } else {\n      right.push(item);\n    }\n  }\n  return left.quickSort().concat(pivot, right.quickSort());\n};\n")])])]),v("h6",{attrs:{id:"数组去重"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组去重"}},[t._v("#")]),t._v(" 数组去重")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function unique(arr) {\n    let newArr = []\n    for (let i = 0 ; i < arr.length; i++ ) {\n        if (newArr.indexOf(arr[i]) === -1) {\n            newArr.push(arr[i])\n        }\n    }\n    return newArr\n}\n")])])]),v("h4",{attrs:{id:"_1、-函数节流和防抖"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、-函数节流和防抖"}},[t._v("#")]),t._v(" 1、 函数节流和防抖")]),t._v(" "),v("ul",[v("li",[t._v("单位时间内，减少函数的调用次数。 提升性能")]),t._v(" "),v("li",[t._v("节流函数：单位时间内函数只调用一次，第一次"),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("\tfunction throttle(fn, time) {\n\t\tlet startTime = 0;\n\t\treturn function () {\n\t\t  const endTime = Date.now();\n\t\t  if (endTime - startTime >= time) {\n\t\t\tfn.apply(this, arguments);  // [[123], 2, 3]\n\t\t  }\n\t\t}\n\t}\n")])])])]),t._v(" "),v("li",[t._v("防抖函数：单位时间内函数只调用一次，最后一次"),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("\tfunction debounce(fn, time) {\n\t\tlet timerId = null;\n\t\treturn function () {\n\t\t\tclearTimeout(timerId);\n\t\t\tconst _self = this;\n\t\t\tconst args = arguments;\n\t\t\ttimerId = setTimeout(function () {\n\t\t\t\tfn.apply(_self, args);\n\t\t\t}, time)\n\t\t}\n\t\n\t}\n")])])])])]),t._v(" "),v("h4",{attrs:{id:"_2、-深度克隆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、-深度克隆"}},[t._v("#")]),t._v(" 2、 深度克隆")]),t._v(" "),v("ul",[v("li",[t._v("目标：需要克隆对象/数组。")]),t._v(" "),v("li",[t._v("实现：需要创建一个新的对象/数组，并且数据与之前一样。这样才能保证修改新对象/数组不会影响原对象数组")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function checkType(target) {\n\treturn Object.prototype.toString.call(target).slice(8, -1);\n}\n\nfunction deepClone(target) {\n\tlet result = null;\n\n\tconst type = checkType(target);\n\tif (type === 'Object') {\n\t\tresult = {};\n\t} else if (type === 'Array') {\n\t\tresult = [];\n\t} else {\n\t\treturn target;\n\t}\n\n\tfor (let key in target) {\n\t\tconst value = target[key];\n\n\t\tresult[key] = deepClone(value);\n\t}\n\t\n\treturn result;\n}\n\n")])])]),v("h4",{attrs:{id:"_3、-请实现数组的flat-数组扁平化处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、-请实现数组的flat-数组扁平化处理"}},[t._v("#")]),t._v(" 3、 请实现数组的flat()  -- 数组扁平化处理")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("const arr = [[1, 2], [[[3]]], [[4], [[[[5]], 6]]], 7];\n//方法一\nArray.prototype.myFlat = function () {\n\tlet result = [];\n\t/*this.forEach((item) => {\n\t\tif (Array.isArray(item)) {\n\t\t\tconst newArr = item.myFlat();\n\t\t\tresult = result.concat(newArr);\n\t\t} else {\n\t\t\tresult.push(item);\n\t\t}\n\t})*/\n\n\tthis.forEach((item) => Array.isArray(item) ? result = result.concat(item.myFlat()) : result.push(item));\n\treturn result;\n}\n\n//方法二\nArray.prototype.myFlat = function (num) {\n\tnum--;\n\tif (num < 0) return this;\n\tlet result = [];\n\tthis.forEach((item) => Array.isArray(item) ? result = result.concat(item.myFlat(num)) : result.push(item));\n\treturn result;\n}\n\n")])])])])}),[],!1,null,null,null);e.default=i.exports}}]);
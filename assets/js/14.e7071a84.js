(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{214:function(e,a,t){"use strict";t.r(a);var s=t(0),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"typescript-基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typescript-基础"}},[e._v("#")]),e._v(" TypeScript (基础)")]),e._v(" "),t("h2",{attrs:{id:"typescript是什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typescript是什么？"}},[e._v("#")]),e._v(" TypeScript是什么？")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。")])]),e._v(" "),t("li",[t("p",[e._v("以下内容均出自于 TS入门教程")])]),e._v(" "),t("li",[t("p",[e._v("以及 Ts 官网的一些内容，没有基础的小伙伴直接看打了⭐️的内容即可。")])])]),e._v(" "),t("h2",{attrs:{id:"typescript-配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typescript-配置"}},[e._v("#")]),e._v(" TypeScript 配置")]),e._v(" "),t("ul",[t("li",[e._v("为什么配置？ TypeScript 还有一个二进制文件，可将 TypeScript 代码编译为 JS 代码. 请记住，浏览器不能编译运行 TypeScript：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("mkdir typescript-tutorial && cd $_\nnpm init -y\n")])])]),t("ul",[t("li",[e._v("然后安装 TypeScript")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm i typescript --save-dev\n")])])]),t("ul",[t("li",[e._v("接下来在 package.json 中的 scripts 下添加如下内容，以便咱们可以轻松地运行 TypeScript 编译器：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  "scripts": {\n    "tsc": "tsc"\n  }\n')])])]),t("ul",[t("li",[e._v("tsc 代表 TypeScript 编译器，只要编译器运行，它将在项目文件夹中查找名为tsconfig.json 的文件。 使用以下命令为 TypeScript 生成配置文件：")])]),e._v(" "),t("p",[t("code",[e._v("npm run tsc -- --init")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("执行成功后会在控制台收到 message TS6071: Successfully created a tsconfig.json file。在项目文件夹中会看到新增了一个 tsconfig.json 文件。tsconfig。json 是一个可怕的配置文件，不要慌。咱们不需要知道它的每一个要点，在下一节中，会介绍入门的相关部分。")])]),e._v(" "),t("li",[t("p",[e._v("创建文件夹")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("mkdir demo\ncd demo\ntouch 1.ts\n")])])]),t("ul",[t("li",[e._v("打开vscode，打开控制台，切换到问题 tab 欧了，开始尝试 ts 吧")])]),e._v(" "),t("h2",{attrs:{id:"⭐️基础类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️基础类型"}},[e._v("#")]),e._v(" ⭐️基础类型")]),e._v(" "),t("h4",{attrs:{id:"boolean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#boolean"}},[e._v("#")]),e._v(" boolean")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let isDone: boolean = false;\n// 使用构造函数 Boolean 创造的对象不是布尔值\n")])])]),t("h4",{attrs:{id:"null-undefined"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null-undefined"}},[e._v("#")]),e._v(" null & undefined")]),e._v(" "),t("ul",[t("li",[e._v("null & undefined是所有类型的子类型")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let u: undefined = undefined;\nlet n: null = null;\nlet num: number = undefined;\nlet u: undefined;\nlet num: number = u;\n")])])]),t("h4",{attrs:{id:"void-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#void-类型"}},[e._v("#")]),e._v(" void 类型")]),e._v(" "),t("ul",[t("li",[e._v("void类型不能赋值给 number")]),e._v(" "),t("li",[e._v("一般表示函数没有返回值。用在变量上没有什么卵用。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function warnUser(): void {\n    console.log(\"This is my warning message\");\n}\nlet a: void = undefined\nlet a: void = 'undefined' // 报错，这是字符串\n")])])]),t("ul",[t("li",[e._v("跟它相似的类型还有undefined 和 null 在不开启严格空检查的情况下 --strictNullChecks，他们可以赋值给所有已经定义过***其他类型***的变量。 也就是说他们是所有类型的子类型")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a: undefined = undefined\nlet a: null = null\n")])])]),t("h4",{attrs:{id:"数字-number"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字-number"}},[e._v("#")]),e._v(" 数字 number")]),e._v(" "),t("ul",[t("li",[e._v("TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。支持十进制和十六进制字面量二进制和八进制字面量。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n")])])]),t("h4",{attrs:{id:"字符串-string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串-string"}},[e._v("#")]),e._v(" 字符串 string")]),e._v(" "),t("ul",[t("li",[e._v("单双引'' \"\"，模板字符的都被视为字符串")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let str:string = ''\n")])])]),t("h2",{attrs:{id:"⭐️数组类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️数组类型"}},[e._v("#")]),e._v(" ⭐️数组类型")]),e._v(" "),t("ul",[t("li",[e._v("有多种声明数组的方式,最简单的方法是使用类型 + []来表示数组：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const arr: number[] = [1,2,3]\nconst arr2: string[] = ['1','2']\n")])])]),t("ul",[t("li",[e._v("数组泛型定义方式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const arr2: Array<number> = [1,2,3,3]\nconst arr2: Array<string> = [1,2,3,3]\n")])])]),t("ul",[t("li",[e._v("接口表示数组")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface NumArr {\n    [index: number]: number;\n}\nlet numArr: NumArr = [1,2,3];\n")])])]),t("ul",[t("li",[e._v("any 类型数组")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let list:any[] = [1,"z",{}]\n')])])]),t("ul",[t("li",[e._v("元组类型声明")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 表示一个确定数组长度和类型的写法\nconst arr:[string,number] = ['2',3]\n")])])]),t("ul",[t("li",[t("p",[e._v("类数组就是伪数组的定义")])]),e._v(" "),t("li",[t("p",[e._v("官方已给了各自的定义接口 Arguments, NodeList, HTMLCollection")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sum() {\n    let args: IArguments = arguments;\n}\n")])])]),t("ul",[t("li",[t("p",[e._v("枚举 enum")]),e._v(" "),t("ul",[t("li",[e._v("js中没有这类型，仿照强类型语言来的。值只能为数字，不定义默认值得情况为从0开始。")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("enum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n// c = 1\n\nenum Number {one = 10, two}\nlet c: Number = Number.two;\n// c = 11\n")])])]),t("h2",{attrs:{id:"⭐️any-类型-任意值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️any-类型-任意值"}},[e._v("#")]),e._v(" ⭐️any 类型(任意值)")]),e._v(" "),t("ul",[t("li",[e._v("指代所有的类型")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a: any = '123'\nlet a = 123; // 不声明默认 any\n")])])]),t("ul",[t("li",[e._v("never\n"),t("ul",[t("li",[e._v("表示永远不存在的值,一般会用来写抛出异常或推断为返回值为never的函数。（比如return一个其他的never类型）")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function error(message: string): never {\n    throw new Error(message);\n}\nerror('a')\n")])])]),t("ul",[t("li",[e._v("object 类型\n"),t("ul",[t("li",[e._v("非简单类型 也就是除number，string，boolean，symbol，null或undefined之外的类型。")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function create(o: object | null): void{\n  console.log(o);\n};\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\ncreate([]); // OK\ncreate('a'); // error\n")])])]),t("h2",{attrs:{id:"⭐️interface-接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️interface-接口"}},[e._v("#")]),e._v(" ⭐️interface 接口")]),e._v(" "),t("ul",[t("li",[e._v("在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n"),t("ul",[t("li",[e._v("对对象的描述,接口一般首字母大写。赋值的时候，变量必须和接口保持一致。")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n")])])]),t("h4",{attrs:{id:"可选属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可选属性"}},[e._v("#")]),e._v(" 可选属性")]),e._v(" "),t("ul",[t("li",[e._v("不想完全匹配某个接口,通过?表示这个属性是可选的,仍然不允许添加未定义的属性")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n")])])]),t("h4",{attrs:{id:"任意属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任意属性"}},[e._v("#")]),e._v(" 任意属性")]),e._v(" "),t("ul",[t("li",[e._v("让接口允许添加任意的属性值")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[propName: string]: any;\n\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n")])])]),t("ul",[t("li",[e._v("一旦定义了任意属性， 那么确定属性和?可选属性都必须是任意属性的子集")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet p:Person = {\n    name: 'zzc',\n    age: 12, // error ， 定义了 propName 必须将值设定为 string 类型\n    gender: 'male' ,\n}\n")])])]),t("h4",{attrs:{id:"只读属性-readonly"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#只读属性-readonly"}},[e._v("#")]),e._v(" 只读属性 readonly")]),e._v(" "),t("ul",[t("li",[e._v("只读属性 readonly相当于是常量了，初次赋值后不能重新赋值 做为变量使用的话用 const，若做为属性则使用readonly。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface demo {\n  readonly a: string; // readonly定以后不能改值\n  b: number\n}\nlet obj: demo = {\n  a: 'ss',\n  b: 1\n}\nobj.a = 'aa' // error\nobj.b = 2 // success\n")])])]),t("ul",[t("li",[e._v("只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface Person {\n    readonly id: number;\n}\nconst tom: Person = {} // error\ntom.id = 1 // error,\n")])])]),t("ul",[t("li",[e._v("会报两次错，第一个是因为指定了 id，但没有给 id 赋值, 第二个错是给只读属性id赋值了")])]),e._v(" "),t("h4",{attrs:{id:"readonlyarray"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#readonlyarray"}},[e._v("#")]),e._v(" ReadonlyArray")]),e._v(" "),t("ul",[t("li",[e._v("通过ReadonlyArray定义的数组，再也无法改变了。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = [1,2,3];\na[0] = 10 // success\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // 注意！ 将readonly的值赋值给一个可变得数组也是不行的。\na = ro as Array<any> // 但是可以用断言重写\n")])])]),t("h2",{attrs:{id:"⭐️函数类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️函数类型"}},[e._v("#")]),e._v(" ⭐️函数类型")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("常见的函数声明方式有： 函数声明 & 函数表达式")])]),e._v(" "),t("li",[t("p",[e._v("用 ts 定义函数要考虑它的输入和输出")]),e._v(" "),t("ul",[t("li",[e._v("函数声明方式定义")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sum(a:number,b:number):number{\n    return a+b\n}\n// 形参和实参数量要一致\nsum(1) // error\nsum(1,2) //3\nsum(1,2,3) // error\n")])])]),t("ul",[t("li",[e._v("函数表达式定义")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 方式 1\nlet sum = function(a:number,b:number):number {\n    return a + b;\n}\n// 方式二\nlet sum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n")])])]),t("ul",[t("li",[t("p",[e._v("方式一中只对等号右侧的匿名函数定义了类型，左边是ts通过类型推论定义出来的")])]),e._v(" "),t("li",[t("p",[e._v("方式二才是给 sum 定义类型，**其中的 => 不是 es6的 => ** ,它用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。")])]),e._v(" "),t("li",[t("p",[e._v("因为和 es6箭头函数可能造成混淆，最好用方式一；")])])]),e._v(" "),t("h4",{attrs:{id:"可选参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可选参数"}},[e._v("#")]),e._v(" 可选参数")]),e._v(" "),t("ul",[t("li",[e._v("通过?给函数定义可选参数")]),e._v(" "),t("li",[e._v("可选参数后面不允许再出现必须参数了")]),e._v(" "),t("li",[e._v("如果给参数添加了默认值，ts 会自动识别为可选，且不受上一条规则的限制。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sum(a:number,b?:number){}\nfunction sum(a?:number,b:number){} // error\nfunction sum(a:number = 1,b:number){} // 默认值，识别为可选，且不报错\n")])])]),t("h4",{attrs:{id:"rest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest"}},[e._v("#")]),e._v(" ...rest")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("使用…rest获取剩余参数，使用数组类型去定义它")])]),e._v(" "),t("li",[t("p",[e._v("剩余参数必须是函数的最后一个参数")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function (a, ...items:any[]){}\nfunction (...items:any[], a){} // error\n")])])]),t("h4",{attrs:{id:"函数的重载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数的重载"}},[e._v("#")]),e._v(" 函数的重载")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。")])]),e._v(" "),t("li",[t("p",[e._v("可以重复定义一个函数的类型")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function say(somthing:string):string;\nfunction say(somthing:number):string;\n// 以上是函数定义\n\n// 以下是函数实现\nfunction say(somthing:string|number):string|number {\n    return somthing\n}\n")])])]),t("ul",[t("li",[e._v("注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。")])]),e._v(" "),t("h2",{attrs:{id:"⭐️类型断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️类型断言"}},[e._v("#")]),e._v(" ⭐️类型断言")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("类型断言（Type Assertion）可以用来手动指定一个值的类型。")])]),e._v(" "),t("li",[t("p",[e._v("断定这个变量的类型是啥")])]),e._v(" "),t("li",[t("p",[e._v("类型断言不是类型转换")])]),e._v(" "),t("li",[t("p",[e._v("两种写法")])]),e._v(" "),t("li",[t("p",[e._v("<类型>值 or 值 as 类型")])]),e._v(" "),t("li",[t("p",[e._v("如果在 tsx 语法中使用，必须用 as")])]),e._v(" "),t("li",[t("p",[e._v("例子")])]),e._v(" "),t("li",[t("p",[e._v("联合类型可以指定一个变量为多种类型，此变量只能访问类型们的共有方法。")])]),e._v(" "),t("li",[t("p",[e._v("但一些情况下我们必须使用某一类型的方法或属性时，就可以用断言")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function say(something:number|string):void{\n    alert(something.length) // 联合类型，报错\n}\n// ==> 使用断言, 在变量前加上 <类型>\nfunction say(something:number|string):void{\n    alert( (<string>something).length ) // success\n}\n")])])]),t("ul",[t("li",[e._v("断言成一个联合类型中不存在的类型是不允许的")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function say(something:number|string):void{\n    alert(<boolean>something.length) // 联合类型没有 boolean ,error\n}\n")])])]),t("h2",{attrs:{id:"⭐️declare-声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#⭐️declare-声明"}},[e._v("#")]),e._v(" ⭐️declare 声明")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("第三方库会暴露出一个变量，让我们在项目中直接使用。")])]),e._v(" "),t("li",[t("p",[e._v("但是 ts 编译时不知道这是啥，编译无法通过。")])]),e._v(" "),t("li",[t("p",[e._v("此时我们就要用 declare var 声明语句来定义他的类型")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" // 比如 jquery\n$('div') // ERROR: Cannot find name 'jQuery'.\n\n// ==> 使用 declare var 第三方库变量: (参数: string) => 返回类型\ndeclare var $: (selector: string) => any;\n\n$('#foo'); // success\n")])])]),t("ul",[t("li",[e._v("declare var 并不是真正的声明一个变量，编译完会删除，仅仅是定义类型。")])]),e._v(" "),t("h4",{attrs:{id:"声明文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#声明文件"}},[e._v("#")]),e._v(" 声明文件")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("通常我们会把声明语句放到一个单独的文件（*.d.ts）中，这就是声明文件")])]),e._v(" "),t("li",[t("p",[e._v("声明文件必需以 .d.ts 为后缀")])]),e._v(" "),t("li",[t("p",[e._v("假如仍然无法解析，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// src/jQuery.d.ts\n\ndeclare var jQuery: (selector: string) => any;\n")])])]),t("ul",[t("li",[e._v("这只是非模块化项目中使用的例子")])]),e._v(" "),t("h4",{attrs:{id:"第三方声明文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三方声明文件"}},[e._v("#")]),e._v(" 第三方声明文件")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。")])]),e._v(" "),t("li",[t("p",[e._v("我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。")])]),e._v(" "),t("li",[t("p",[e._v("@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm i @types/jquery -D\n")])])]),t("ul",[t("li",[e._v("可以在这个页面搜索你需要的声明文件。")])]),e._v(" "),t("h4",{attrs:{id:"自定义声明文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义声明文件"}},[e._v("#")]),e._v(" 自定义声明文件")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("声明文件有以下方法")]),e._v(" "),t("ul",[t("li",[e._v("全局变量：通过 "),t("script")])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);
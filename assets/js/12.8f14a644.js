(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{211:function(v,_,l){"use strict";l.r(_);var i=l(0),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"react"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[v._v("#")]),v._v(" React")]),v._v(" "),l("ul",[l("li",[v._v("一个用于构建用户界面的js库")]),v._v(" "),l("li",[v._v("特点：\n"),l("ul",[l("li",[v._v("声明式")]),v._v(" "),l("li",[v._v("组件化")])])]),v._v(" "),l("li",[v._v("创建虚拟DOM对象\n"),l("ul",[l("li",[l("code",[v._v("React.createElement(type, props, children, children...)")])]),v._v(" "),l("li",[l("code",[v._v("<h1>xxx</h1>")])])])]),v._v(" "),l("li",[v._v("jsx语法：\n"),l("ul",[l("li",[v._v("用来创建虚拟DOM对象")]),v._v(" "),l("li",[v._v("以<开头, 会以标签语法解析（如果html同名标签就会解析成同名元素，不是就当做组件解析）")]),v._v(" "),l("li",[v._v("以{开头，将里面代码当做js代码解析（if、for..不能使用）")])])]),v._v(" "),l("li",[v._v("创建组件两个方式\n"),l("ul",[l("li",[v._v("工厂函数：过去不能使用state、生命周期函数，现在可以通过hooks使用")]),v._v(" "),l("li",[v._v("ES6类：定义复杂组件")])])]),v._v(" "),l("li",[v._v("组件三大属性\n"),l("ul",[l("li",[v._v("state： 定义状态数据，用来更新组件")]),v._v(" "),l("li",[v._v("props： 用来组件外向组件内传递可变的数据")]),v._v(" "),l("li",[v._v("refs：用来获取dom元素/组件实例对象。 能不用就不用")])])]),v._v(" "),l("li",[v._v("受控组件\n"),l("ul",[l("li",[v._v("通过state/onChange收集表单数据")])])]),v._v(" "),l("li",[v._v("组件间通信***：\n"),l("ul",[l("li",[v._v("props： 父子组件通信")]),v._v(" "),l("li",[v._v("pubsub： 兄弟/祖孙组件通信\n"),l("ul",[l("li",[v._v("subscribe(msg, callback)")]),v._v(" "),l("li",[v._v("publish(msg, data)")])])]),v._v(" "),l("li",[v._v("redux： 适用所有场景")]),v._v(" "),l("li",[v._v("context： 祖孙组件通信")])])]),v._v(" "),l("li",[v._v("脚手架\n"),l("ul",[l("li",[v._v("用来快速创建基于xxx库的模板项目")])])]),v._v(" "),l("li",[v._v("react-router\n"),l("ul",[l("li",[v._v("前端路由用来开发SPA")]),v._v(" "),l("li",[v._v("整个应用只有一个完整页面")]),v._v(" "),l("li",[v._v("点击链接不会刷新不会跳转，只会更新局部内容，修改浏览历史记录")]),v._v(" "),l("li",[v._v("实现原理：\n"),l("ul",[l("li",[v._v("禁止a标签的默认行为")]),v._v(" "),l("li",[v._v("自定义a标签的点击事件，通过history修改浏览历史记录")]),v._v(" "),l("li",[v._v("监听浏览历史记录的变化，修改网页的内容（切换组件）")])])])])]),v._v(" "),l("li",[v._v("ant-design\n"),l("ul",[l("li",[v._v("React UI组件库")])])]),v._v(" "),l("li",[v._v("高阶组件\n"),l("ul",[l("li",[v._v("本质上是一个函数，接收一个组件作为参数，返回一个新组件（新组件包装了传入的组件，所以新组件就能以props方式给传入组件传递数据）")]),v._v(" "),l("li",[v._v("用来复用组件代码")]),v._v(" "),l("li",[v._v("如：withRouter、Form.create、getFieldDecorator、connect")])])]),v._v(" "),l("li",[v._v("Fragment\n"),l("ul",[l("li",[v._v("用来充当根标签，减少页面元素")])])]),v._v(" "),l("li",[v._v("context\n"),l("ul",[l("li",[v._v("用来祖孙组件通信")]),v._v(" "),l("li",[v._v("创建：const Context = React.createContext(defaultValue)")]),v._v(" "),l("li",[v._v("使用：\n"),l("ul",[l("li",[l("Context.Provider",{attrs:{value:"{xxx}"}},[l("xxx")],1)],1),v._v(" "),l("li",[l("Context.Consumer",[v._v("{ (xxx) => { 使用xxx } }")])],1)])])])]),v._v(" "),l("li",[v._v("新生命周期***：\n"),l("ul",[l("li",[v._v("static getDerivedStateFromProps() {}  状态是根据props来生成的")]),v._v(" "),l("li",[v._v("getSnapShotBeforeUpdate() {} 一般不用，能在真正渲染之前操作DOM")])])]),v._v(" "),l("li",[v._v("错误边界\n"),l("ul",[l("li",[v._v("一个React组件，用来处理错误")]),v._v(" "),l("li",[v._v("定义生命周期函数")]),v._v(" "),l("li",[v._v("getDerivedStateFromError() {}  根据错误，更新状态，从而重新渲染组件（渲染备用方法）")]),v._v(" "),l("li",[v._v("compoenntDidCatch() {} 收集错误信息")])])]),v._v(" "),l("li",[v._v("代码分割\n"),l("ul",[l("li",[v._v("提取成单独文件，动态加载")]),v._v(" "),l("li",[v._v("import")]),v._v(" "),l("li",[v._v("React.lazy")]),v._v(" "),l("li",[v._v("react-loadable")])])]),v._v(" "),l("li",[v._v("服务器渲染\n"),l("ul",[l("li",[v._v("ReactDOMServer.renderToString()")]),v._v(" "),l("li",[v._v("next  -- create-next-app")])])]),v._v(" "),l("li",[v._v("性能优化\n"),l("ul",[l("li",[v._v("shouldComponentUpdate")]),v._v(" "),l("li",[v._v("PureComponent")])])]),v._v(" "),l("li",[v._v("hooks\n"),l("ul",[l("li",[v._v("用来在纯函数组件中使用state和生命周期函数")]),v._v(" "),l("li",[v._v("const [ state, method ] = React.useState(defaultValue)")]),v._v(" "),l("li",[v._v("React.useEffect()")])])]),v._v(" "),l("li",[v._v("redux\n"),l("ul",[l("li",[v._v("是什么？")]),v._v(" "),l("li",[v._v("一个状态管理库")]),v._v(" "),l("li",[v._v("作用：\n"),l("ul",[l("li",[v._v("集中性管理多个组件的共享状态")])])]),v._v(" "),l("li",[v._v("原则：\n"),l("ul",[l("li",[v._v("单一数据源")]),v._v(" "),l("li",[v._v("数据是只读")]),v._v(" "),l("li",[v._v("使用纯函数更新数据\n"),l("ul",[l("li",[v._v("同样的输入，必定同样的输出")])])])])]),v._v(" "),l("li",[v._v("工作流程：\n"),l("ul",[l("li",[v._v("读取状态\n"),l("ul",[l("li",[v._v("store.getState()")])])]),v._v(" "),l("li",[v._v("更新状态\n"),l("ul",[l("li",[v._v("调用action creators来创建action对象")]),v._v(" "),l("li",[v._v("调用store.dispatch(action),就会触发reducers的调用")]),v._v(" "),l("li",[v._v("reducers(prevState, action)生成新的状态数据")]),v._v(" "),l("li",[v._v("新状态数据会交给store管理（更新了状态）。")]),v._v(" "),l("li",[v._v("此时，之前store绑定过subscribe方法，这个subscribe方法就会触发。执行里面的回调。从而重新渲染组件，会将最新状态数据传入组件中。组件中就能得到最新的状态数据了~")])])])])]),v._v(" "),l("li",[v._v("使用")]),v._v(" "),l("li",[v._v("action-creators\n"),l("ul",[l("li",[v._v("用来创建action对象的工厂函数模块")]),v._v(" "),l("li",[v._v("action: {type: 要操作的类型, data: 操作的数据}")]),v._v(" "),l("li",[v._v("同步：返回值是action对象")]),v._v(" "),l("li",[v._v("异步：返回值是函数。")])])]),v._v(" "),l("li",[v._v("action-types\n"),l("ul",[l("li",[v._v("用来定义action.type类型常量模块")])])]),v._v(" "),l("li",[v._v("reducers\n"),l("ul",[l("li",[v._v("用来根据prevState和action来生成newState")]),v._v(" "),l("li",[v._v("纯函数")])])]),v._v(" "),l("li",[v._v("store\n"),l("ul",[l("li",[v._v("用来集中性管理状态数据")])])]),v._v(" "),l("li",[v._v("在index.js人口文件，需要给App组件包一个Provider，用来根据state变化重新渲染")]),v._v(" "),l("li",[v._v("action-creators -> action-types -> reducers -> 定义容器组件（将redux内容传给UI组件） -> 将之前使用UI组件换成容器组件 -> 在UI组件中使用传入props")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{218:function(e,n,t){"use strict";t.r(n);var s=t(0),l=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),t("h4",{attrs:{id:"let和const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let和const"}},[e._v("#")]),e._v(" let和const")]),e._v(" "),t("ul",[t("li",[e._v("let\n"),t("ol",[t("li",[e._v("作用:\n与var类似, 用于声明一个变量")]),e._v(" "),t("li",[e._v("特点:\n在块作用域内有效\n不能重复声明\n不会预处理, 不存在提升")]),e._v(" "),t("li",[e._v("应用:\n循环遍历加监听\n使用let取代var是趋势")])])]),e._v(" "),t("li",[e._v("const\n"),t("ol",[t("li",[e._v("作用:\n定义一个常量")]),e._v(" "),t("li",[e._v("特点:\n不能修改\n其它特点同let")]),e._v(" "),t("li",[e._v("应用:\n保存不用改变的数据")])])]),e._v(" "),t("li",[e._v("let 定义 变量")]),e._v(" "),t("li",[e._v("const 定义 常量\n"),t("ol",[t("li",[e._v("默认变量使用let定义，今后let使用很多，只有确定不变的量用const  90%以上用let定义的")]),e._v(" "),t("li",[e._v("默认变量使用const定义，今后const使用很多，只有确定可变的量用let  90%以上用const定义的\n默认就用const定义，只有后面的值发生变化，在改为let")])])])]),e._v(" "),t("h4",{attrs:{id:"变量的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量的解构赋值"}},[e._v("#")]),e._v(" 变量的解构赋值")]),e._v(" "),t("ol",[t("li",[e._v("理解:")])]),e._v(" "),t("ul",[t("li",[e._v("从对象或数组中提取数据, 并赋值给变量(多个)\n"),t("ul",[t("li",[t("code",[e._v("const person = {name: 'jack', age: 18};")]),e._v(" "),t("code",[e._v("const { age, sex, name } = person;")]),e._v(" "),t("code",[e._v("console.log(name, age, sex);")])])])])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("对象的解构赋值: 没有顺序关系\n"),t("code",[e._v("let {n, a} = {n:'tom', a:12}")])]),e._v(" "),t("li",[e._v("数组的解构赋值: 根据顺序一一对应\n"),t("code",[e._v("let [a,b] = [1, 'atguigu'];")])]),e._v(" "),t("li",[e._v("用途\n"),t("ul",[t("li",[e._v("给多个形参赋值")])])]),e._v(" "),t("li",[e._v("对函数参数解构赋值，一个解构赋值语法对应一个参数（与结构赋值语法中多少个变量没有关系）")])]),e._v(" "),t("h4",{attrs:{id:"模板字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串"}},[e._v("#")]),e._v(" 模板字符串")]),e._v(" "),t("ol",[t("li",[e._v("模板字符串 : 简化字符串的拼接")])]),e._v(" "),t("ul",[t("li",[e._v("模板字符串必须用 `` 包含")]),e._v(" "),t("li",[e._v("变化的部分使用${xxx}定义")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const person = {name: 'jack', age: 18};\n  console.log('姓名：' + person.name + ' 年龄：' + person.age);\n  console.log(`姓名：${person.name} 年龄: ${person.age}`);\n")])])]),t("h4",{attrs:{id:"对象的简写方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的简写方法"}},[e._v("#")]),e._v(" 对象的简写方法")]),e._v(" "),t("p",[e._v("简化的对象写法")]),e._v(" "),t("ul",[t("li",[e._v("省略同名的属性值")]),e._v(" "),t("li",[e._v("省略方法的function")]),e._v(" "),t("li",[e._v("例如:"),t("div",{staticClass:"language-let x = 1; extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let y = 2;\nlet point = {\n  x,\n  y,\n  setX (x) {this.x = x}\n};\n")])])])])]),e._v(" "),t("h4",{attrs:{id:"形参默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#形参默认值"}},[e._v("#")]),e._v(" 形参默认值")]),e._v(" "),t("p",[e._v("形参的默认值----当不传入参数的时候默认使用形参里的默认值")]),e._v(" "),t("pre",[t("code",[e._v("function Point(x = 1,y = 2) {\nthis.x = x;\nthis.y = y;\n}\n")])]),e._v(" "),t("p",[e._v("默认值：没有传值就使用默认值，传值了就使用传入的值")]),e._v(" "),t("h4",{attrs:{id:"三点运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三点运算符"}},[e._v("#")]),e._v(" 三点运算符")]),e._v(" "),t("p",[e._v("用途")]),e._v(" "),t("ol",[t("li",[e._v("rest(可变)参数\n"),t("ul",[t("li",[e._v("用来取代arguments 但比 arguments 灵活,只能是最后部分形参参数")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function fun(...values) {\n    console.log(arguments);\n    arguments.forEach(function (item, index) {\n        console.log(item, index);\n    });\n    console.log(values);\n    values.forEach(function (item, index) {\n        console.log(item, index);\n    })\n}\nfun(1,2,3);\n")])])])]),e._v(" "),t("li",[e._v("扩展运算符")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  let arr1 = [1,3,5];\n  let arr2 = [2,...arr1,6];\n  arr2.push(...arr1);\n  function sum(a, ...args) {\n    // ...运算符 取代 arguments\n    console.log(args); // 真数组\n    console.log(arguments); // 伪数组\n  }\n")])])]),t("h4",{attrs:{id:"箭头函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[e._v("#")]),e._v(" 箭头函数")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("作用: 定义匿名函数")])]),e._v(" "),t("li",[t("p",[e._v("基本语法:")]),e._v(" "),t("ul",[t("li",[e._v("没有参数: () => console.log('xxxx')")]),e._v(" "),t("li",[e._v("一个参数: i => i+2")]),e._v(" "),t("li",[e._v("大于一个参数: (i,j) => i+j")]),e._v(" "),t("li",[e._v("函数体不用大括号: 默认返回结果")]),e._v(" "),t("li",[e._v("函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回")])])]),e._v(" "),t("li",[t("p",[e._v("使用场景: 多用来定义回调函数")])]),e._v(" "),t("li",[t("p",[e._v("箭头函数的特点：\n1、简洁\n2、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this\n3、扩展理解： 箭头函数的this看外层的是否有函数，\n如果有，外层函数的this就是内部箭头函数的this，\n如果没有，则this是window。")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 箭头函数\n  const fn = () => {};\n  // 形参只有一个, 可以省略括号\n  const fn1 = x => { console.log(x); };\n  // 形参没有或者有多个\n  const fn2 = (x, y) => {};\n  console.log(fn1(1));\n  // 当代码只有一条语法时, 可以省略大括号，会将语句结果作为函数的返回值返回\n  const fn3 = x => x + 1;\n  console.log(fn3(1));\n  // 当代码没有或多条语句时\n  const fn4 = x => {\n    console.log(x);\n    return x + 1;\n  }\n")])])]),t("h4",{attrs:{id:"promise对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise对象"}},[e._v("#")]),e._v(" Promise对象")]),e._v(" "),t("ol",[t("li",[e._v("promise就是一个异步编程的解决方案，用来解决回调地狱问题")]),e._v(" "),t("li",[e._v("理解:")])]),e._v(" "),t("ul",[t("li",[e._v("Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)")]),e._v(" "),t("li",[e._v("有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱')")]),e._v(" "),t("li",[e._v("ES6的Promise是一个构造函数, 用来生成promise实例")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("使用promise基本步骤(2步):")])]),e._v(" "),t("ul",[t("li",[e._v("创建promise对象"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let promise = new Promise((resolve, reject) => {\n    //初始化promise状态为 pending\n  //执行异步操作\n  if(异步操作成功) {\n    resolve(value);//修改promise的状态为fullfilled\n  } else {\n    reject(errMsg);//修改promise的状态为rejected\n  }\n})\n")])])])]),e._v(" "),t("li",[e._v("调用promise的then()"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("promise.then(function(\n  result => console.log(result),\n  errorMsg => alert(errorMsg)\n))\n")])])])])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("promise对象的3个状态")])]),e._v(" "),t("ul",[t("li",[e._v("pending: 初始化状态")]),e._v(" "),t("li",[e._v("fullfilled: 成功状态")]),e._v(" "),t("li",[e._v("rejected: 失败状态")])]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("应用:")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("使用promise实现超时处理")])]),e._v(" "),t("li",[t("p",[e._v("使用promise封装处理ajax请求")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let request = new XMLHttpRequest();\nrequest.onreadystatechange = function () {\n}\nrequest.responseType = 'json';\nrequest.open(\"GET\", url);\nrequest.send();\n")])])])]),e._v(" "),t("li",[t("p",[e._v("new Promise(), 会创建promise实例对象，实例对象内部默认是pending状态（初始化状态）")]),e._v(" "),t("ul",[t("li",[e._v("resolve()  将promise状态由初始化状态改为 fullfilled 成功的状态")]),e._v(" "),t("li",[e._v("reject() 将promise状态由初始化状态改为 rejected 失败的状态")]),e._v(" "),t("li",[e._v("promise状态只能有初始化状态改为成功/失败的状态。不能由成功变成失败或者失败变成成功")])])]),e._v(" "),t("li",[t("p",[e._v("promise实例对象， then方法")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("promise.then((result) => {\n// 当promise对象状态变成成功的状态时，会调用当前函数\n// 成功的回调函数可以接受resolve方法传入参数\nconsole.log('成功的回调函数触发了~');\nconsole.log(result);\nsum(1, 2);\n}, (error) => {\n// 当promise对象状态变成失败的状态时，会调用当前函数\n// 失败的回调函数可以接受reject方法传入参数\nconsole.log('失败的回调函数触发了~');\nconsole.log(error);\n})\n")])])]),t("h4",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[e._v("#")]),e._v(" Symbol")]),e._v(" "),t("ul",[t("li",[e._v("前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境")]),e._v(" "),t("li",[e._v("每次调用Symbol函数，返回一个唯一的symbol数据\n一般给对象设置唯一的属性。\n多了一个数据类型：Symbol\n"),t("ul",[t("li",[e._v("Symbol：\n概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象)")]),e._v(" "),t("li",[e._v("特点：\n"),t("ul",[t("li",[e._v("Symbol属性对应的值是唯一的，解决命名冲突问题")]),e._v(" "),t("li",[e._v("Symbol值不能与其他数据进行计算，包括同字符串拼串")]),e._v(" "),t("li",[e._v("for in, for of遍历时不会遍历symbol属性。")])])]),e._v(" "),t("li",[e._v("使用：\n"),t("ul",[t("li",[e._v("调用Symbol函数得到symbol值"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let symbol = Symbol();\nlet obj = {};\nobj[symbol] = 'hello';\n")])])])]),e._v(" "),t("li",[e._v("传参标识"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let symbol = Symbol('one');\nlet symbol2 = Symbol('two');\nconsole.log(symbol);// Symbol('one')\nconsole.log(symbol2);// Symbol('two')\n")])])])]),e._v(" "),t("li",[e._v("内置Symbol值\n"),t("ul",[t("li",[e._v("除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。")])]),e._v(" "),t("ul",[t("li",[e._v("Symbol.iterator")])]),e._v(" "),t("ul",[t("li",[e._v("对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)")])])])])])])])]),e._v(" "),t("h4",{attrs:{id:"iterator遍历器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iterator遍历器"}},[e._v("#")]),e._v(" Iterator遍历器")]),e._v(" "),t("ul",[t("li",[e._v("概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制")]),e._v(" "),t("li",[e._v("作用：\n"),t("ul",[t("li",[e._v("为各种数据结构，提供一个统一的、简便的访问接口；")]),e._v(" "),t("li",[e._v("使得数据结构的成员能够按某种次序排列；")]),e._v(" "),t("li",[e._v("ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。\n工作原理：")])]),e._v(" "),t("ul",[t("li",[e._v("创建一个指针对象(遍历器对象)，指向数据结构的起始位置。")]),e._v(" "),t("li",[e._v("第一次调用next方法，指针自动指向数据结构的第一个成员")]),e._v(" "),t("li",[e._v("接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员")]),e._v(" "),t("li",[e._v("每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}\n"),t("ul",[t("li",[e._v("value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。")]),e._v(" "),t("li",[e._v("当遍历结束的时候返回的value值是undefined，done值为false\n原生具备iterator接口的数据(可用for of遍历)")])])])]),e._v(" "),t("ul",[t("li",[e._v("Array")]),e._v(" "),t("li",[e._v("arguments")]),e._v(" "),t("li",[e._v("set容器")]),e._v(" "),t("li",[e._v("map容器")]),e._v(" "),t("li",[e._v("String")]),e._v(" "),t("li",[e._v("。。。")])])]),e._v(" "),t("li",[e._v("iterator是一个接口机制，为了让所有数据用统一的方式遍历（ for of ）\n"),t("ul",[t("li",[e._v("通过查看数据类型上是否有Symbol(Symbol.iterator)方法")]),e._v(" "),t("li",[e._v("String 、Array、Set、Map、 arguments、dom元素集合（querySelectorAll）")])])]),e._v(" "),t("li",[e._v("遍历的方法\n"),t("ul",[t("li",[e._v("forEach只能数组使用，推荐使用")]),e._v(" "),t("li",[e._v("for 只能数组使用, 性能最好")]),e._v(" "),t("li",[e._v("while / do while 任意值使用")]),e._v(" "),t("li",[e._v("for in 通常用于对象")]),e._v(" "),t("li",[e._v("for of 当你不确定要遍历的是什么数据类型。这时候用for of")])])])]),e._v(" "),t("h4",{attrs:{id:"generator函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator函数"}},[e._v("#")]),e._v(" Generator函数")]),e._v(" "),t("pre",[t("code",[e._v("概念：\n  1、ES6提供的解决异步编程的方案之一\n  2、Generator函数是一个状态机，内部封装了不同状态的数据，\n  3、用来生成遍历器对象\n  4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果\n特点：\n  1、function 与函数名之间有一个星号\n  2、内部用yield表达式来定义不同的状态\n  例如：\n    function* generatorExample(){\n      let result = yield 'hello';  // 状态值为hello\n      yield 'generator'; // 状态值为generator\n    }\n  3、generator函数返回的是指针对象(接11章节里iterator)，而不会执行函数内部逻辑\n  4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}\n  5、再次调用next方法会从上一次停止时的yield处开始，直到最后\n  6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。\n")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* fn() {\n    console.log('函数开始执行了~');\n    const flag = true;\n    const result = yield flag ? 123 : 456;\n    console.log(result);\n    console.log('函数执行完了~');\n  }\n  // 执行generator函数，返回值是一个iterator对象\n  const iteratorObj = fn();\n  console.log(iteratorObj);\n  // 通过iterator对象的next方法执行函数体代码（推着函数动一下）\n  const result1 = iteratorObj.next(111);\n  console.log(result1);  // {value: 123, done: false}  value 看yield后面表达式的值, done 看函数是否执行完毕：没有执行完就是false 执行完了就是true\n  const result2 = iteratorObj.next(222);\n  console.log(result2);\n  // 手动给对象添加iterator接口\n  console.log(Symbol.iterator);\n  const person = {\n    name: 'jack',\n    age: 18,\n    sex: '男'\n  }\n  Object.prototype[Symbol.iterator] = function* () {\n    for (let key in this) {\n      yield this[key];\n    }\n  }\n\n")])])]),t("ul",[t("li",[e._v("案例")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/*\n 需求：请求a数据，再请求b数据，请求c数据\n   */\n\n  function* generator() {\n    console.log('函数开始执行了~');\n\n    const result1 = yield setTimeout(() => {\n      console.log('请求回来了a数据');\n      // 请求成功，让generator继续执行\n      iteratorObj.next('a数据');\n    }, 3000);\n\n    const result2 = yield setTimeout(() => {\n      console.log('请求回来了b数据');\n      // 请求成功，让generator继续执行\n      iteratorObj.next('b数据');\n    }, 2000);\n\n    const result3 = yield setTimeout(() => {\n      console.log('请求回来了c数据');\n      // 请求成功，让generator继续执行\n      iteratorObj.next('c数据');\n    }, 1000);\n\n    console.log(result1, result2, result3);\n\n    console.log('函数执行完毕了~');\n  }\n\n  const iteratorObj = generator();\n  // 为了执行第一个请求\n  iteratorObj.next();\n")])])]),t("h4",{attrs:{id:"async函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async函数"}},[e._v("#")]),e._v(" async函数")]),e._v(" "),t("ul",[t("li",[e._v("async函数(源自ES2017 - ES8)")]),e._v(" "),t("li",[e._v("概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作\n本质： Generator的语法糖")]),e._v(" "),t("li",[e._v("语法：\nasync function foo(){\nawait 异步操作;\nawait 异步操作；\n}")]),e._v(" "),t("li",[e._v("特点：\n"),t("ul",[t("li",[e._v("不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行")]),e._v(" "),t("li",[e._v("返回的总是Promise对象，可以用then方法进行下一步操作")]),e._v(" "),t("li",[e._v("async取代Generator函数的星号*，await取代Generator的yield")]),e._v(" "),t("li",[e._v("语意上更为明确，使用简单，经临床验证，暂时没有任何副作用")])])]),e._v(" "),t("li",[e._v("案例1")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function asyncFn() {\n    console.log('函数开始执行了~');\n    /* const promise = new Promise((resolve, reject) => setTimeout(() => reject(123456), 2000));\n    const promise = new Promise((resolve, reject) => setTimeout(reject.bind(null, 123456), 2000));\n    */\n    const promise = new Promise((resolve, reject) => setTimeout(resolve.bind(null, 123456), 2000));\n    // const promise = Promise.resolve();\n    // await只等promise对象：等promise对象状态由初始化变成成功状态。\n    // （一旦promise对象状态是初始化状态，一直等。一旦promise对象状态变成成功的状态，就不等了，执行后面代码）\n    // 一旦promise对象状态变成失败的状态，就不执行后面代码(如果捕获了async函数promise的异常，就不报错，没有捕获，就会报错)\n    // result的值就是resolve()传入的参数\n    const result = await promise;\n    console.log(result);\n    await promise;\n    console.log('函数执行完毕了~');\n    return 666;\n  }\n  // async函数返回值是一个promise对象: 默认是resolved状态\n  // 如果函数中有promise对象变成失败的状态，就是rejected状态\n  const result = asyncFn();\n  result\n    // 看async函数里面返回值，就是result的值\n    .then((result) => {\n      console.log(result);\n    })\n    .catch((error) => {\n      console.log(error);\n    })\n  console.log(result);\n")])])]),t("ul",[t("li",[e._v("案例2")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function asyncFn() {\n\n    const result1 = await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        console.log('a数据请求成功了~');\n        resolve('a数据');\n      }, 3000)\n    })\n\n    const result2 = await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        console.log('b数据请求成功了~');\n        resolve('b数据');\n      }, 2000)\n    })\n\n    const result3 = await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        console.log('c数据请求成功了~');\n        resolve('c数据');\n      }, 2000)\n    })\n\n    console.log(result1, result2, result3);\n    return [result1, result2, result3];\n  }\n\n  const promise = asyncFn();\n\n  promise\n    .then((res) => {\n      console.log(res); // [result1, result2, result3]\n    })\n")])])]),t("h4",{attrs:{id:"class类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class类"}},[e._v("#")]),e._v(" class类")]),e._v(" "),t("ol",[t("li",[e._v("通过class定义类/实现类的继承")]),e._v(" "),t("li",[e._v("在类中通过constructor定义构造方法")]),e._v(" "),t("li",[e._v("通过new来创建类的实例")]),e._v(" "),t("li",[e._v("通过extends来实现类的继承")]),e._v(" "),t("li",[e._v("通过super调用父类的构造方法")]),e._v(" "),t("li",[e._v("重写从父类中继承的一般方法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 定义类：构造函数\n  class Father {\n    // 给实例对象添加属性\n    constructor(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    // 给实例对象添加方法\n    setName(name) {\n      this.name = name;\n    }\n  }\n  // 定义子类继承父类，自动继承父类的属性和方法\n  // 使用继承必须在constructor函数中调用super方法或者不写constructor\n  class Son extends Father{\n    // 给实例对象添加属性\n    constructor(name, age, sex) {\n      super(name, age); // 调用父类的构造方法： constructor\n      this.sex = sex;\n    }\n    // 给实例对象添加方法\n    setAge(age) {\n      this.age = age;\n    }\n  }\n  console.log(Father.prototype);\n  console.log(typeof Son);\n  const s = new Son('bob', 20, '男');\n  console.log(s);\n")])])]),t("h4",{attrs:{id:"字符串扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串扩展"}},[e._v("#")]),e._v(" 字符串扩展")]),e._v(" "),t("ol",[t("li",[e._v("String.prototype.includes(str) : 判断是否包含指定的字符串")]),e._v(" "),t("li",[e._v("String.prototype.startsWith(str) : 判断是否以指定字符串开头")]),e._v(" "),t("li",[e._v("String.prototype.endsWith(str) : 判断是否以指定字符串结尾")]),e._v(" "),t("li",[e._v("String.prototype.repeat(count) : 重复指定次数")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const str = 'atguigu';\n  console.log(str.includes('gug')); // true\n  console.log(str.startsWith('atg')); // true\n  console.log(str.endsWith('gu')); // true\n  console.log(str.repeat(3)); // 'atguiguatguiguatguigu'\n")])])]),t("h4",{attrs:{id:"数值扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数值扩展"}},[e._v("#")]),e._v(" 数值扩展")]),e._v(" "),t("ol",[t("li",[e._v("二进制与八进制数值表示法: 二进制用0b, 八进制用0o")]),e._v(" "),t("li",[e._v("Number.isFinite(i) : 判断是否是有限大的数")]),e._v(" "),t("li",[e._v("Number.isNaN(i) : 判断是否是NaN")]),e._v(" "),t("li",[e._v("Number.isInteger(i) : 判断是否是整数")]),e._v(" "),t("li",[e._v("Number.parseInt(str) : 将字符串转换为对应的数值")]),e._v(" "),t("li",[e._v("Math.trunc(i) : 直接去除小数部分")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" console.log(0o666); // 0 - 7\n  console.log(0b1010); // 0 - 1   8421法\n  console.log(Infinity); // 正无穷大\n  console.log(-Infinity); // 负无穷大\n  console.log(NaN); // not a number\n  console.log(Number.isFinite(Infinity)); // false\n  console.log(Number.isNaN(NaN)); // true  x !== x\n  console.log(NaN === NaN); // NaN不与任何数相等，包括它自身\n  console.log(Number.isInteger(1.1)); // false\n  console.log(Number.parseInt('123a.123')); // 123  整型：整数\n  console.log(Number.parseFloat('123.123')); // 123.123 浮点型：小数\n  console.log(Math.trunc(456.865)); // 456\n  console.log(Math.floor(456.865)); // 456\n")])])]),t("h4",{attrs:{id:"数组扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组扩展"}},[e._v("#")]),e._v(" 数组扩展")]),e._v(" "),t("ol",[t("li",[e._v("Array.from(v) : 将伪数组对象或可遍历对象转换为真数组")]),e._v(" "),t("li",[e._v("Array.of(v1, v2, v3) : 将一系列值转换成数组")]),e._v(" "),t("li",[e._v("Array.prototype.find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素")]),e._v(" "),t("li",[e._v("Array.prototype.findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 伪数组对象\n  const btns = document.querySelectorAll('button');\n  // 将伪数组转化为真数组\n  const newBtns1 = Array.from(btns);\n  console.log(newBtns1);\n  const newBtns2 = Array.prototype.slice.call(btns);\n  console.log(newBtns2);\n  const newBtns3 = [...btns];\n  console.log(newBtns3);\n  console.log(Array.of(1, true, {})); // [1, true, {}]\n  const arr = [{age: 18}, {age: 19}, {age: 20}, {age: 21}];\n  // const obj = arr.find((item, index, arr) => item.age === 20);\n  const index = arr.findIndex((item, index, arr) => item.age === 20);\n  console.log(index);\n")])])]),t("h4",{attrs:{id:"对象扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象扩展"}},[e._v("#")]),e._v(" 对象扩展")]),e._v(" "),t("ol",[t("li",[e._v("Object.is(v1, v2)\n"),t("ul",[t("li",[e._v("判断2个数据是否完全相等")])])]),e._v(" "),t("li",[e._v("Object.assign(target, source1, source2..)\n"),t("ul",[t("li",[e._v("将源对象的属性复制到目标对象上")])])]),e._v(" "),t("li",[e._v("直接操作 "),t("strong",[e._v("proto")]),e._v(" 属性")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj2 = {};\nobj2.__proto__ = obj1;\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 全等运算符的问题\n  console.log(0 === -0); // true  false\n  console.log(NaN === NaN); // false  true\n  // Object.is方法解决\n  console.log(Object.is(1, 1)); // true\n  console.log(Object.is(0, -0)); // false\n  console.log(Object.is(NaN, NaN)); // true\n//is方法用原生实现\n  function is(a, b) {\n    /*if (a === b) {\n      // 判断 0 和 -0 的特殊情况 返回 false\n      // 0 和 0 / -0 和 -0 的情况返回 true\n      // return !(-a === b);\n      return !(-1 / a === 1 / b);\n    } else {\n      // 判断 NaN 和 NaN 的特殊情况\n      return a !== a && b !== b;\n    }*/\n    // return a === b ? ((-1 / a === 1 / b) ? false : true) : (a !== a && b !== b ? true : false);\n    // return (a === b && (!(-1 / a === 1 / b)) || (a !== a && b !== b);\n    return a === b ? !(-1 / a === 1 / b) : a !== a && b !== b;\n  }\n  console.log(is(0, -0)); // false\n  console.log(is(0, 0)); // true\n  console.log(is({}, {})); // false\n  console.log(is(NaN, NaN)); // true\n  console.log(is(true, true)); // true\n  const obj = {};\n  const obj1 = {name: 'jack'};\n  const obj2 = {age: 18};\n  // 将后面目标对象上的属性和方法复制到源对象上\n  const result = Object.assign(obj, obj1, obj2);\n  console.log(result === obj);\n")])])]),t("h4",{attrs:{id:"深度克隆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深度克隆"}},[e._v("#")]),e._v(" 深度克隆")]),e._v(" "),t("ul",[t("li",[e._v("数据类型：\n"),t("ul",[t("li",[e._v("数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型")])]),e._v(" "),t("ul",[t("li",[e._v("基本数据类型：\n特点： 存储的是该对象的实际数据")]),e._v(" "),t("li",[e._v("对象数据类型：\n特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里")])])]),e._v(" "),t("li",[e._v("复制数据\n"),t("ul",[t("li",[e._v("基本数据类型存放的就是实际的数据，可直接复制\nlet number2 = 2;\nlet number1 = number2;")]),e._v(" "),t("li",[e._v("克隆数据：对象/数组\n"),t("ul",[t("li",[e._v("区别： 浅拷贝/深度拷贝\n判断： 拷贝是否全部产生了新的数据还是拷贝的是数据的引用\n"),t("ul",[t("li",[e._v("知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj = {username: 'kobe'}\nlet obj1 = obj; // obj1\n```复制了obj在栈内存的引用\n")])])])])]),e._v("\n2、常用的拷贝技术\n"),t("ul",[t("li",[e._v("arr.concat(): 数组浅拷贝\n2). arr.slice(): 数组浅拷贝")]),e._v(" "),t("li",[e._v("JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据")]),e._v(" "),t("li",[e._v("浅拷贝包含函数数据的对象/数组")]),e._v(" "),t("li",[e._v("深拷贝包含函数数据的对象/数组")])])])])]),e._v(" "),t("li",[e._v("浅度克隆")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  let obj3 = Object.assign({}, obj1);\n  obj3.hobby.push('rap');\n  console.log(obj3);\n  console.log(obj1);\n")])])]),t("ul",[t("li",[e._v("深度克隆\n"),t("ul",[t("li",[e._v("JSON能实现深度克隆，不能克隆函数数据")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj1 = {name: 'jack', age: 18, hobby: ['篮球', '唱', '跳'], setName (name) {this.name = name;}};\nconst json = JSON.stringify(obj1);\nconst obj4 = JSON.parse(json);\nconsole.log(obj1, obj4);\nobj4.hobby.push('rap');\nconsole.log(obj1, obj4);\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 检查数据类型\n  function checkType(target) {\n    return Object.prototype.toString.call(target).slice(8, -1);\n  }\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 深度克隆： 深度克隆所有数据\n  function deepClone(target) {\n    // 因为不确定克隆的是什么数据，但是能确定的是一定是引用数据类型\n    let result = null;\n    // 检查数据的类型\n    const type = checkType(target);\n    // 判断数据的类型，如果是对象/数组就处理，不是就直接返回\n    if (type === 'Object') {\n      result = {};\n    } else if (type === 'Array') {\n      result = [];\n    } else {\n      // 其他类型就直接返回\n      return target;\n    }\n    // for in 即能遍历对象也能遍历数组\n    for (let key in target) {\n      // 获取属性值\n      const value = target[key];\n      // 将克隆的值作为新对象的某个属性的值\n      // const newValue = deepClone(value);\n      // result[key] = newValue;\n      result[key] = deepClone(value);\n    }\n    return result;\n  }\n  const person = {name: 'jack', age: 18, hobby: ['篮球', '唱', '跳'], sex: { option1: '男', option2: '女' }, setName (name) {this.name = name;}};\n  const newObj = deepClone(person);\n  newObj.hobby.push('rap');\n  console.log(person, newObj);\n")])])]),t("h4",{attrs:{id:"set和map数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set和map数据结构"}},[e._v("#")]),e._v(" Set和Map数据结构")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Set容器 : 无序不可重复的多个value的集合体")]),e._v(" "),t("ul",[t("li",[e._v("Set()")]),e._v(" "),t("li",[e._v("Set(array)")]),e._v(" "),t("li",[e._v("Set.prototype.add(value) 给set容器添加一个值")]),e._v(" "),t("li",[e._v("Set.prototype.delete(value) 删除一个")]),e._v(" "),t("li",[e._v("Set.prototype.has(value)")]),e._v(" "),t("li",[e._v("Set.prototype.clear() 清空所有")]),e._v(" "),t("li",[e._v("size")])])]),e._v(" "),t("li",[t("p",[e._v("Map容器 : 无序的 key不重复的多个key-value的集合体")]),e._v(" "),t("ul",[t("li",[e._v("Map()")]),e._v(" "),t("li",[e._v("Map(array)")]),e._v(" "),t("li",[e._v("set(key, value)//添加")]),e._v(" "),t("li",[e._v("get(key)")]),e._v(" "),t("li",[e._v("delete(key)")]),e._v(" "),t("li",[e._v("has(key)")]),e._v(" "),t("li",[e._v("clear()")]),e._v(" "),t("li",[e._v("size")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const arr = [2, 5, 8, 5, 1, 4, 8];\n  const s1 = new Set(arr);\n  console.log(s1);\n  // 数组去重\n  console.log([...new Set(arr)]);\n\n  s1.add(9);\n  console.log(s1);\n  console.log(s1.has(9));\n  s1.clear();\n  console.log(s1);\n\n  // 无序的 key不重复的多个key-value的集合体\n  const array = [1, 2, 3];\n  const m1 = new Map([[{name: 'jack'}, function fn() {}], [array, true], [array, false]]);\n  console.log(m1);\n")])])]),t("h4",{attrs:{id:"es7-常用的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es7-常用的"}},[e._v("#")]),e._v(" ES7(常用的)")]),e._v(" "),t("ol",[t("li",[e._v("指数运算符(幂): **")]),e._v(" "),t("li",[e._v("Array.prototype.includes(value) : 判断数组中是否包含指定value")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(3 ** 3);//27\nconst arr = [1, 2, 5, 6, 8];\nconsole.log(arr.includes(3));//true\n")])])]),t("h4",{attrs:{id:"es8-常用的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es8-常用的"}},[e._v("#")]),e._v(" ES8(常用的)")]),e._v(" "),t("p",[t("strong",[e._v("==async函数也是ES8中提出的==")])]),e._v(" "),t("ul",[t("li",[e._v("Object.values()")]),e._v(" "),t("li",[e._v("Object.entries()")]),e._v(" "),t("li",[e._v("Object.keys()")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" const person = {name: 'jack', age: 18}; // [['name', 'jack'], ['age': 18]]\n  // 提取对象中所有属性名，作为一个数组返回\n  console.log(Object.keys(person));\n  // 提取对象中所有属性值，作为一个数组返回\n  console.log(Object.values(person));\n  console.log(Object.entries(person)); // [['name', 'jack'], ['age': 18]]\n")])])]),t("h4",{attrs:{id:"es9-常用的-promise-finally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es9-常用的-promise-finally"}},[e._v("#")]),e._v(" ES9(常用的)Promise.finally")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve, reject) => setTimeout(reject, 1000));\n  promise\n    .then(() => {\n      console.log('then');\n    })\n    .catch(() => {\n      console.log('catch');\n    })\n    .finally(() => {\n      // 不管成功还是失败都会触发\n      console.log('finally');\n    })\n")])])]),t("h4",{attrs:{id:"es10-常用的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es10-常用的"}},[e._v("#")]),e._v(" ES10(常用的)")]),e._v(" "),t("ul",[t("li",[e._v("Array扩展方法\n"),t("ul",[t("li",[e._v("数组降维、数组的扁平化")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 数组降维、数组的扁平化\n  const arr = [[1, 2], [[[3]]], [[4], [[[[5]], 6]]]];\n  console.log(arr.flat(1));\n  console.log(arr.flat(Infinity));\n/*\n    1. flat 全部降成1维\n    2. 可以传参，根据参数降维\n  flat方法的实现源代码\n  Array.prototype.flat = function (num) {\n    // this 就指向要处理的数组  --\x3e arr.flat()\n    let result = [];\n    /!*this.forEach((item, index) => {\n      if (Array.isArray(item)) {\n        result = result.concat(item.flat());\n      } else {\n        result.push(item);\n      }\n    })*!/\n    this.forEach((item) => Array.isArray(item) ? result = result.concat(item.flat()) : result.push(item));\n    return result;\n  }\n\n  Array.prototype.flat = function (num) {\n    // this 就指向要处理的数组  --\x3e arr.flat()\n    num--;\n    if (num < 0) return this;\n    let result = [];\n    /!*this.forEach((item, index) => {\n      if (Array.isArray(item)) {\n        result = result.concat(item.flat());\n      } else {\n        result.push(item);\n      }\n    })*!/\n    this.forEach((item) => Array.isArray(item) ? result = result.concat(item.flat(num)) : result.push(item));\n    return result;\n  }\n*/\n")])])]),t("ul",[t("li",[e._v("动态import")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 按需加载\n  document.getElementById('btn').onclick = function () {\n    // 只会加载一次\n    import('./a.js');\n  }\n")])])]),t("h4",{attrs:{id:"函数节流和函数防抖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数节流和函数防抖"}},[e._v("#")]),e._v(" 函数节流和函数防抖")]),e._v(" "),t("ul",[t("li",[e._v("节流函数")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 绑定滚轮事件\n  // 需求：滚轮事件发现单位时间内触发回调函数的次数太多，性能不好\n  // 解决：让函数调用次数更少\n  // 节流函数：在单位时间内让函数只调用一次\n  document.onscroll = throttle(function (e) {\n    console.log('滚轮事件触发了~');\n    console.log(e);\n    console.log(this);\n  }, 1000)\n\n  // 节流函数\n  function throttle(fn, time) {\n    // 开始时间\n    let startTime = 0;\n    // 实际上下面函数就是DOM事件回调函数\n    return function () {\n\n      // 结束时间: 调用当前函数的时间\n      const endTime = Date.now();\n      // fn函数的this指向问题，参数有问题（少event）\n      if (endTime - startTime >= time) {\n        // 大于1s, 可以触发， 小于1s就不触发\n        fn.apply(this, arguments);\n        // 重置开始时间\n        startTime = endTime;\n      }\n    }\n  }\n")])])]),t("ul",[t("li",[e._v("防抖函数")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 绑定滚轮事件\n  // 需求：滚轮事件发现单位时间内触发回调函数的次数太多，性能不好\n  // 解决：让函数调用次数更少\n  // 节流函数：在单位时间内让函数只调用一次，是第一次生效\n  // 防抖函数：在单位时间内让函数只调用一次，是最后一次生效\n  document.onscroll = debounce(function (e) {\n    console.log('滚轮事件触发了~');\n    console.log(e);\n    console.log(this);\n  }, 1000)\n  // 防抖函数\n  function debounce(fn, time) {\n    let timerId = null;\n    // 实际上下面函数就是DOM事件回调函数\n    return function () {\n      clearTimeout(timerId);\n      const args = arguments;\n      timerId = setTimeout(() => {\n        // fn函数的this指向问题，参数有问题（少event）\n        // 大于1s, 可以触发， 小于1s就不触发\n        fn.apply(this, args);\n      }, time);\n    }\n  }\n")])])])])}),[],!1,null,null,null);n.default=l.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{224:function(a,e,t){"use strict";t.r(e);var n=t(0),s=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"typescript-进阶"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typescript-进阶"}},[a._v("#")]),a._v(" TypeScript (进阶)")]),a._v(" "),t("h2",{attrs:{id:"类型的别名-type"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型的别名-type"}},[a._v("#")]),a._v(" 类型的别名 type")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("type strAria = string; // 给 string 类型定义了 strAria别名\nconst str: strAria = 'abc';\n\ntype fnAria = () => string;\nfunction (callback:fnAria):void {\n    callback();\n}\n")])])]),t("h2",{attrs:{id:"字符串字面量类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串字面量类型"}},[a._v("#")]),a._v(" 字符串字面量类型")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("type EventName = 'xm' | 'xh' | 'xb';\nconst str : EventName = 'xb'\nconst elseStr : EventName = 'xf' // error, 不在这几个名字当中\n")])])]),t("ul",[t("li",[a._v("我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。")]),a._v(" "),t("li",[a._v("注意，类型别名与字符串字面量类型都是使用 type 进行定义。")])]),a._v(" "),t("h2",{attrs:{id:"元组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元组"}},[a._v("#")]),a._v(" 元组")]),a._v(" "),t("ul",[t("li",[a._v("一个带有不同值的数组")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let confusion: [string,number] = ['a',1]; // 这就叫元组\n复制代码let confusion: [string, number];\nconfusion[0] = 'a'; // 可以只赋值给某一项\nconfusion[1] = 'b' // error , 元组的第2项必须为 number\n\n// 如果直接给元组赋值，要完全提供其定义好的类型和长度\nconfusion = ['a',1]\n")])])]),t("h2",{attrs:{id:"越界的元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#越界的元素"}},[a._v("#")]),a._v(" 越界的元素")]),a._v(" "),t("ul",[t("li",[a._v("当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let xcatliu: [string, number];\nxcatliu = ['Xcat Liu', 25]; // ok\nxcatliu.push('http://xcatliu.com/'); // ok\nxcatliu.push(true); // error, 不能添加非字符串和 number 的值\n")])])]),t("h2",{attrs:{id:"枚举-enum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#枚举-enum"}},[a._v("#")]),a._v(" 枚举 Enum")]),a._v(" "),t("ul",[t("li",[a._v("用于定义一个类型的值在一定的范围内")]),a._v(" "),t("li",[a._v("使用 enum 定义枚举")]),a._v(" "),t("li",[a._v("枚举的成员从0开始递增，并且key 和 value 会互相映射")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('enum Colors { Red, Yellow, Blue }\nColors[\'Red\'] === 0 // true  从0开始递增\nColors[0] === \'Red\' // 相互映射\n\n// 枚举事实上会编译成如下\nvar Color;\n(function (Color) {\n    Color[Color["Red"] = 0] = "Red";\n    Color[Color["Yellow"] = 1] = "Yellow";\n    Color[Color["Blue"] = 2] = "Blue";\n})(Color || (Color = {}));\n')])])]),t("h2",{attrs:{id:"手动赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手动赋值"}},[a._v("#")]),a._v(" 手动赋值")]),a._v(" "),t("ul",[t("li",[a._v("枚举的值是可以二次赋值的，被重新赋值的后一项会接着上一项的key递增")]),a._v(" "),t("li",[a._v("如果两个枚举值重复了，不会报错，但是值会被覆盖")]),a._v(" "),t("li",[a._v("可以为小数或者负数，递增步数仍然为 1")]),a._v(" "),t("li",[a._v("配合断言，可以让枚举不是数字")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("enum Colors { Red = 1, Yellow, Blue }\nColors['Red'] = 2 // 重新赋值\nColors['Yellow'] // 3 下一项 + 1\n\nColors['Yellow'] = 1 // 此时 Red 和 Blue 值重复了， Colors[2] 只会取最后的值，因为覆盖了。\nconsole.log(Colors[2] === \"Red\"); // false\nconsole.log(Colors[2] === \"Blue\"); // true\n\n// 负数\nColors['Red'] = 2.1\nColors['Yellow'] // 3.1\n")])])]),t("h2",{attrs:{id:"断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#断言"}},[a._v("#")]),a._v(" 断言")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("enum Colors { Red = 1, Yellow, Blue = <any>\"S\" }\nColors['Blue'] // 'S'\n")])])]),t("ul",[t("li",[t("p",[a._v("计算所得项")])]),a._v(" "),t("li",[t("p",[a._v("上面我们使用的枚举都是常数项")])]),a._v(" "),t("li",[t("p",[a._v("计算所得项就是通过计算赋值的枚举，只在编译阶段求值")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("enum Colors { Red = 1, Yellow, Blue = 1 + 1 }\n\n// 由于编译时求值 计算所得项的后一项如果没有赋值，会因为无法获得初始值报错\nenum Colors { Red = 'asdasd'.length, Yellow, Blue } // error \n")])])]),t("ul",[t("li",[t("p",[a._v("当满足以下条件时，枚举成员被当作是常数：")])]),a._v(" "),t("li",[t("p",[a._v("不具有初始化函数并且之前的枚举成员是常数(单纯声明的时候)。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。")])]),a._v(" "),t("li",[t("p",[a._v("使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：")])]),a._v(" "),t("li",[t("p",[a._v("数字字面量  =>  Red = 1")])]),a._v(" "),t("li",[t("p",[a._v("引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用")])]),a._v(" "),t("li",[t("p",[a._v("带括号的常数枚举表达式")])]),a._v(" "),t("li",[t("p",[a._v("+, -, ~ 一元运算符应用于常数枚举表达式")])]),a._v(" "),t("li",[t("p",[a._v("+, -, *, /, %, <<, >>, >>>, &, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错")])]),a._v(" "),t("li",[t("p",[a._v("所有其它情况的枚举成员被当作是需要计算得出的值。")])]),a._v(" "),t("li",[t("p",[a._v("被当成是常量的例子")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("enum Colors { Red, Yellow, Blue }\n// Colors['Red'] ==> 0 Colors['Yellow'] ==> 1 Colors['Blue'] ==> 2\n\nenum Directions { \n\tUp = 996,\n    Down = Up,\n    Left = Colors['Red'],\n    Right = (1 + 1),\n    UpLeft = 2 % 1,\n    DownLeft = 'a' - 1， // 结果 NaN 报错\n}\n")])])]),t("h2",{attrs:{id:"常数枚举"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常数枚举"}},[a._v("#")]),a._v(" 常数枚举")]),a._v(" "),t("ul",[t("li",[a._v("使用 const enum 定义的枚举")]),a._v(" "),t("li",[a._v("常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。")]),a._v(" "),t("li")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('const enum Color {Red, Green, Blue = "blue".length};// error 不能包含计算成员\n')])])]),t("h2",{attrs:{id:"外部枚举"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外部枚举"}},[a._v("#")]),a._v(" 外部枚举")]),a._v(" "),t("ul",[t("li",[a._v("使用 declare enum 定义的枚举类型")]),a._v(" "),t("li",[a._v("declare 定义的类型只会用于编译时的检查，编译结果中会被删除。")]),a._v(" "),t("li",[a._v("外部枚举与声明语句一样，常出现在声明文件中。")]),a._v(" "),t("li",[a._v("同时使用 declare 和 const 也是可以的：")]),a._v(" "),t("li",[a._v("类与接口 implements")]),a._v(" "),t("li",[a._v("类用于面向对象")]),a._v(" "),t("li",[a._v("接口用于对象形状的描述")]),a._v(" "),t("li",[a._v("不同的类之间某一部分可能行为一致，那么为了不重复写两个一样的接口，可以使用implements 实现重用interface")]),a._v(" "),t("li",[a._v('implements 中文译为 "实现"')]),a._v(" "),t("li",[a._v("比如有个狗类，有个猫类，它们都有 eat 这个方法，实现的形状一致")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Behavior {\n    eat(food: string): void\n}\n\nclass Dog implements Behavior {\n  eat(foot) {}    \n}\nclass Cat implements Behavior {\n  eat(foot) {}\n}\n\nclass habaDog extends Dog implements Behavior {\n  // 此时哈巴狗继承了狗类，就有了 eat 方法   \n}\n")])])]),t("h2",{attrs:{id:"多个实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多个实现"}},[a._v("#")]),a._v(" 多个实现")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Behavior { // 行为接口\n  eat(food: string): void\n}\n\ninterface Appearance { // 外表接口\n  fur:string\n}\n\nclass Dog implements Behavior {\n  eat(foot) {}    \n}\n\nclass habaDog extends Dog implements Behavior, Appearance {\n    fur = ''  \n}\n\n")])])]),t("h2",{attrs:{id:"接口继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口继承"}},[a._v("#")]),a._v(" 接口继承")]),a._v(" "),t("ul",[t("li",[a._v("接口也是可以继承接口的")]),a._v(" "),t("li",[a._v("继承老爸姓名")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Fa {\n  surname: string\n}\n\ninterface Son extends Fa {\n  name: string\n}\n\nconst obj: Son = {\n  surname : 'z',\n  name: 'zc'\n}\n")])])]),t("h2",{attrs:{id:"接口继承class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口继承class"}},[a._v("#")]),a._v(" 接口继承class")]),a._v(" "),t("ul",[t("li",[a._v("用于将某个 class 定义为类型，并往上再添加类型。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class Fa {\n  constructor() {}\n  suck(){\n\n  }\n}\n\ninterface Son extends Fa {\n  suck():void;\n  name: string;\n}\n")])])]),t("h2",{attrs:{id:"泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[a._v("#")]),a._v(" 泛型")]),a._v(" "),t("ul",[t("li",[a._v("指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。")]),a._v(" "),t("li",[a._v("使用 "),t("T",[a._v(" 代表类型的变量, T 只是约定用法，可以任意指定。")])],1)]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function getArrVal<T>(something:T):Array<T> {\n  return [something];\n}\n\ngetArrVal<string>('z') // ['z'] 使用时再指定类型\ngetArrVal('z') // 不写也没事 ts 会推论出来\n\n// 接口型定义\ninterface Test<T> {\n  num : T\n}\nlet o : Test<string> = {\n  num: '1'\n}\n")])])]),t("ul",[t("li",[a._v("可以一次性定义多个泛型")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Test<T,U> {\n  name?: T,\n  num : U\n}\nlet o : Test<string,number> = {\n  num: 1\n}\n\nfunction Test<T,U> (a:T,b:U):void { // 函数定义\n  console.log(a,b);\n  \n}\nTest<string,number>('1',1)\n")])])]),t("h2",{attrs:{id:"泛型约束"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型约束"}},[a._v("#")]),a._v(" 泛型约束")]),a._v(" "),t("ul",[t("li",[a._v("泛型无法知道具体的类型，所以无法操作它的属性和方法")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function Test<T> (a:T):void {\n  console.log(a.length);  // error\n}\nTest<string>('1')\n")])])]),t("ul",[t("li",[a._v("当你明确知道泛型中有哪些属性方法时，可以通过 extends 进行泛型约束,写在声明函数名的后面")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface hasLengthProp {\n    length : number;\n}\nfunction Test<T extends hasLengthProp>(a:T):void {\n    console.log(a.length);\n}\n")])])]),t("ul",[t("li",[t("p",[a._v("泛型可以约束泛型")])]),a._v(" "),t("li",[t("p",[a._v("相当于泛型的继承")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function test<T extends U,U>(a:T,b:U):void {\n    console.log(a);\n}\n\ntest({a:1,b:2,c:3},{a:1,b:2})\n")])])]),t("h2",{attrs:{id:"泛型接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型接口"}},[a._v("#")]),a._v(" 泛型接口")]),a._v(" "),t("ul",[t("li",[a._v("在接口中定义泛型,如果接口中只定义了一个匿名函数的类型，直接赋值即可。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Test {\n  <T>(name:T):void\n}\nlet say:Test; // 直接赋值\n\nsay = function<T>(name:T):void {\n  console.log(name);\n}\nsay('haha')\n")])])]),t("ul",[t("li",[a._v("如果接口中包含多个属性，这个接口就是一个对象的描述")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Test {\n  demo<T>(name:T):void;\n  a:string;\n}\nlet say:Test; // 对象的描述\n\nsay.demo = function<T>(name:T):void {\n  console.log(name);\n}\nsay.demo('haha')\n")])])]),t("h2",{attrs:{id:"泛型类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型类"}},[a._v("#")]),a._v(" 泛型类")]),a._v(" "),t("ul",[t("li",[a._v("就是在泛型里面使用类型变量")]),a._v(" "),t("li",[a._v("类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class Name<T>{\n  num:T;\n  constructor(num:T) {\n    this.num = num\n  }\n  add:(x:T,y:T) => T;\n}\nlet addName = new Name<number>(10)\naddName.num = 10\naddName.add = (x:number,y:number) => {\n  return 1+2\n}\n")])])]),t("h2",{attrs:{id:"泛型默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型默认值"}},[a._v("#")]),a._v(" 泛型默认值")]),a._v(" "),t("ul",[t("li",[a._v("当代码中没有直接指定，并且类型推论也没有成功时，默认值会生效")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function say<T = any>(name: T):void {\n    alert(name)\n}\nsay<string>('1') // ok\nsay(true) // ok\n")])])]),t("h2",{attrs:{id:"声明合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#声明合并"}},[a._v("#")]),a._v(" 声明合并")]),a._v(" "),t("ul",[t("li",[a._v("就是说声明两个同样的接口、类或者函数，会进行合并操作。")]),a._v(" "),t("li",[a._v("合并的属性的类型必须是唯一的")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("interface Alarm {\n    price: number;\n     alert(s: string): string;\n}\ninterface Alarm {\n    weight: number;\n    alert(s: string, n: number): string;\n}\n===> 相当于\ninterface Alarm {\n    price: number;\n    weight: number;\n   \talert(s: string, n: number): string;\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);
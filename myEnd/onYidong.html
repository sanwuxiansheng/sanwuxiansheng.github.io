<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>有关移动端 | 久念的个人博客</title>
    <meta name="description" content="村上春树说过:总之岁月漫长，然而值得等待">
    <link rel="icon" href="../.vuepress/public/img/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.2412c64d.css" as="style"><link rel="preload" href="/assets/js/app.27194c62.js" as="script"><link rel="preload" href="/assets/js/2.660d2c2d.js" as="script"><link rel="preload" href="/assets/js/30.601df3fc.js" as="script"><link rel="prefetch" href="/assets/js/10.7e6638b6.js"><link rel="prefetch" href="/assets/js/11.3c882514.js"><link rel="prefetch" href="/assets/js/12.8f14a644.js"><link rel="prefetch" href="/assets/js/13.7ad68c93.js"><link rel="prefetch" href="/assets/js/14.e7071a84.js"><link rel="prefetch" href="/assets/js/15.c868008a.js"><link rel="prefetch" href="/assets/js/16.96d600e7.js"><link rel="prefetch" href="/assets/js/17.216bbb18.js"><link rel="prefetch" href="/assets/js/18.132d27eb.js"><link rel="prefetch" href="/assets/js/19.94321978.js"><link rel="prefetch" href="/assets/js/20.5ff51867.js"><link rel="prefetch" href="/assets/js/21.5034d234.js"><link rel="prefetch" href="/assets/js/22.6e708266.js"><link rel="prefetch" href="/assets/js/23.afc937fb.js"><link rel="prefetch" href="/assets/js/24.6a2d27de.js"><link rel="prefetch" href="/assets/js/25.40bacf7a.js"><link rel="prefetch" href="/assets/js/26.94f1f69e.js"><link rel="prefetch" href="/assets/js/27.9009e8ee.js"><link rel="prefetch" href="/assets/js/28.d79333d2.js"><link rel="prefetch" href="/assets/js/29.3451956d.js"><link rel="prefetch" href="/assets/js/3.25a26ba3.js"><link rel="prefetch" href="/assets/js/31.80e18c66.js"><link rel="prefetch" href="/assets/js/32.e6dd8fca.js"><link rel="prefetch" href="/assets/js/33.beab8789.js"><link rel="prefetch" href="/assets/js/34.7a02303d.js"><link rel="prefetch" href="/assets/js/4.f74a38f4.js"><link rel="prefetch" href="/assets/js/5.4c28bf85.js"><link rel="prefetch" href="/assets/js/6.11aca216.js"><link rel="prefetch" href="/assets/js/7.8d7844b8.js"><link rel="prefetch" href="/assets/js/8.56426901.js"><link rel="prefetch" href="/assets/js/9.ecc15e63.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2412c64d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">久念的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/frontEnd/" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/interviewEnd/" class="nav-link">有关面试</a></div><div class="nav-item"><a href="/myEnd/" class="nav-link router-link-active">个人随笔</a></div><div class="nav-item"><a href="/backEnd/" class="nav-link">优文转载</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术论坛" class="dropdown-title"><span class="title">技术论坛</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.im/timeline" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.jianshu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/frontEnd/" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/interviewEnd/" class="nav-link">有关面试</a></div><div class="nav-item"><a href="/myEnd/" class="nav-link router-link-active">个人随笔</a></div><div class="nav-item"><a href="/backEnd/" class="nav-link">优文转载</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术论坛" class="dropdown-title"><span class="title">技术论坛</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.im/timeline" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.jianshu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/myEnd/" class="sidebar-link">性能优化</a></li><li><a href="/myEnd/test.html" class="sidebar-link">浏览器缓存及其机制</a></li><li><a href="/myEnd/onYidong.html" class="active sidebar-link">有关移动端</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/myEnd/onPay.html" class="sidebar-link">vue移动端支付</a></li><li><a href="/myEnd/SVN.html" class="sidebar-link">svn</a></li><li><a href="/myEnd/git.html" class="sidebar-link">git</a></li><li><a href="/myEnd/shouxiedaima.html" class="sidebar-link">自己封装的一些方法和函数</a></li><li><a href="/myEnd/quacking.html" class="sidebar-link">数组去重的方法</a></li><li><a href="/myEnd/array.html" class="sidebar-link">数组常用的一些方法</a></li><li><a href="/myEnd/css.html" class="sidebar-link">CSS隐藏元素的N种实现方式。</a></li><li><a href="/myEnd/mescroll.html" class="sidebar-link">mescroll.js的使用</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="有关移动端"><a href="#有关移动端" class="header-anchor">#</a> 有关移动端</h3> <h3 id="问题一：vue移动端适配"><a href="#问题一：vue移动端适配" class="header-anchor">#</a> 问题一：vue移动端适配</h3> <h4 id="使用vue-cli安装好一个vue的项目"><a href="#使用vue-cli安装好一个vue的项目" class="header-anchor">#</a> 使用vue-cli安装好一个vue的项目</h4> <div class="language- extra-class"><pre class="language-text"><code>
 npm install -g vue-cli
 vue init webpack my-project
 cd my-project
 npm run dev
</code></pre></div><h4 id="配置vue插件-lib-flexible"><a href="#配置vue插件-lib-flexible" class="header-anchor">#</a> 配置vue插件 lib-flexible</h4> <ol><li><h6 id="安装插件命令"><a href="#安装插件命令" class="header-anchor">#</a> 安装插件命令</h6></li></ol> <div class="language- extra-class"><pre class="language-text"><code>
npm install lib-flexible --save-dev

</code></pre></div><ol start="2"><li><h6 id="mian-js文件中引入"><a href="#mian-js文件中引入" class="header-anchor">#</a> mian.js文件中引入</h6></li></ol> <div class="language- extra-class"><pre class="language-text"><code>
import 'lib-flexible/flexible'

</code></pre></div><ol start="3"><li><h6 id="安装px2rem-loader"><a href="#安装px2rem-loader" class="header-anchor">#</a> 安装px2rem loader</h6></li></ol> <div class="language- extra-class"><pre class="language-text"><code>npm insatll px2rem-loader --save-dev
</code></pre></div><ol start="4"><li><h6 id="配置px2rem-loader"><a href="#配置px2rem-loader" class="header-anchor">#</a> 配置px2rem-loader</h6></li></ol> <ul><li>在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，如：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>exports.cssLoaders = function (options) {
  options = options || {}

  const cssLoader = {
    loader: 'css-loader',
    options: {
      sourceMap: options.sourceMap
    }
  }

  const postcssLoader = {
    loader: 'postcss-loader',
    options: {
      sourceMap: options.sourceMap
    }
  }

  const px2remLoader = {
    loader: 'px2rem-loader',
    options: {
      remUnit: 75
    }
  }
</code></pre></div><ul><li><p>这里的‘75’是根据设计稿来的，如果设计稿图是750px的这里就写75</p></li> <li><p>在generateLoaders方法中添加px2remLoader</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>
function generateLoaders (loader, loaderOptions) {
    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader, px2remLoader]

    if (loader) {
      loaders.push({
        loader: loader + '-loader',
        options: Object.assign({}, loaderOptions, {
          sourceMap: options.sourceMap
        })
      })
    }
</code></pre></div><ul><li>至此通过脚手架vue-cli 搭建的vue项目就适配好了，可以直接使用px</li></ul> <h3 id="有关跨域的问题"><a href="#有关跨域的问题" class="header-anchor">#</a> 有关跨域的问题</h3> <h4 id="开发环境下"><a href="#开发环境下" class="header-anchor">#</a> 开发环境下</h4> <ul><li>只需要在config文件夹下面的index.js文件中添加如下代码</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
module.exports = {
  dev: {

    // Paths
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {
      '/api': {
        pathRewrite: {
          '^/api': '',//重写,
        },
        target: 'https://XXXXX',//后端接口地址
        changeOrigin: true,//是否允许跨越
      },
      '/php': {
        pathRewrite: {
            '^/php/': '',//重写,
        },
        target: 'https://XXXXX',//后端接口地址
        changeOrigin: true//是否允许跨越
      }
    },

    // Various Dev Server settings
    host: '192.168.0.133', // can be overwritten by process.env.HOST
    // host: 'localhost',
    port: 8080, 

</code></pre></div><ul><li>配置完成后，在使用ajax请求时只需要在接口前面加上<code>/api</code>或者<code>/php/</code>即可</li></ul> <h4 id="生产环境下"><a href="#生产环境下" class="header-anchor">#</a> 生产环境下</h4> <ul><li><p>因为我现在开发的项目是在同一域名下所以不需要进行跨域，但我还是为大家找到了解决方法</p></li> <li><p>生产环境下跨域需要配置nginx</p></li> <li><p>设置nginx配置文件：</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>
location /api {
    add_header 'Access-Control-Allow-Origin' '*';
    proxy_pass http://fanyi.baidu.com/v2transapi;
}

</code></pre></div><ul><li><p>平常我们团队开发时都在公司的局域网内，调用接口也是局域网内部的，但是项目上线时，请求接口是线上服务器端的，那么就有接口之间的来回切换问题。</p></li> <li><p>在使用vue-cli搭建项目以后，做相关配置就可以实现，不用手动更改接口路径，也可以请求不同环境下的接口。</p></li></ul> <ol><li><p>设置不同的接口地址</p> <ul><li>先找到以下文件</li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>
　　/config/dev.env.js
　　/config/prod.env.js

</code></pre></div><ul><li>在dev.env.js里面添加内容如</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
'use strict'
const merge = require('webpack-merge')
const prodEnv = require('./prod.env')

module.exports = merge(prodEnv, {
  NODE_ENV: '&quot;development&quot;',
  API_ROOT:'&quot;http://192.168.1.130:18080/cheduo&quot;'
})

</code></pre></div><ul><li>这就是本地测试环境请求后台接口的域名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
 API_ROOT:'&quot;http://192.168.1.130:18080/cheduo&quot;'

</code></pre></div><ul><li>在prod.env.js里面添加内容如下</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
'use strict'
module.exports = {
  NODE_ENV: '&quot;production&quot;',
  API_ROOT:'&quot;https://mc.cheduo.com/cheduo&quot;'
}

</code></pre></div><ul><li>这是我们上传服务器以后，请求后台接口的域名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
API_ROOT:'&quot;https://mc.cheduo.com/cheduo&quot;'

</code></pre></div><ol start="2"><li>在代码中调用设置好的参数</li></ol> <ul><li>比如我在本项目中重新封装axios(api文件在/src/api/index.js中)，将配置好的接口地址作为baseURL拼接到接口路径中，应用参数部分如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
const root = process.env.API_ROOT;

</code></pre></div><ul><li>最后重新启动项目就可以了，当npm run dev的时候就运行在生产环境，当npm run build的时候就是正式的线上环境。</li></ul> <h3 id="有关项目打包上线后的问题"><a href="#有关项目打包上线后的问题" class="header-anchor">#</a> 有关项目打包上线后的问题</h3> <h5 id="打包上线运行后空白页面"><a href="#打包上线运行后空白页面" class="header-anchor">#</a> 打包上线运行后空白页面</h5> <ul><li><p>一般碰到空白页面都是静态资源在打包时出现了问题</p></li> <li><p>打包后的资源使用了绝对根目录路径，因此将项目部署到特定目录下，其引入的资源路径无法被正确解析</p></li> <li><p>所以需要在打包时将config/index.js文件中的build对象的assetsPublicPath:'./'，改为assetsPublicPath:'/'或者是相应的绝对目录,如下：</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>
  build: {
    // Template for index.html
    index: path.resolve(__dirname, '../../../asv/index.html'),

    // Paths
    assetsRoot: path.resolve(__dirname, '../../../html/asv'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/html/asv/',

</code></pre></div><h5 id="vue项目打包后css背景图路径不对"><a href="#vue项目打包后css背景图路径不对" class="header-anchor">#</a> vue项目打包后css背景图路径不对</h5> <ul><li>只需要在build/utils.js文件中添加如下一行代码即可。</li></ul> <p><code>publicPath:'../../'</code></p> <ul><li>添加结果如下</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
if (options.extract) {
      return ExtractTextPlugin.extract({
        use: loaders,
        fallback: 'vue-style-loader',
        publicPath:'../../'
      })
    } else {
      return ['vue-style-loader'].concat(loaders)
    }

</code></pre></div><ul><li>重启项目后该问题解决</li></ul> <h3 id="关于后台接口传参类型的问题"><a href="#关于后台接口传参类型的问题" class="header-anchor">#</a> 关于后台接口传参类型的问题</h3> <ul><li>博主之前一直是对的Java的接口，传参类型也是json类型，所以没有碰到过这种问题，只是最近的这个项目的后台是PHP的且要求post请求使用form表单格式发送数据</li></ul> <h5 id="解决方法"><a href="#解决方法" class="header-anchor">#</a> 解决方法</h5> <ol><li>下载qs</li></ol> <div class="language- extra-class"><pre class="language-text"><code>
npm install qs --save-dev

</code></pre></div><ol start="2"><li><p>在main.js文件和封装的axios请求中引入</p></li> <li><p>在发送post请求是将参数使用qs.stringify()进行数据转换</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>
import axios from 'axios'
export default function ajax(url,data={},method='GET'){
  return new Promise((resolve,reject)=&gt;{
    let promise
    // 执行异步ajax请求
    if (method==='GET') {
      promise = axios.get(url,{params:data})  // params配置，指定的是query参数
    }else{
      promise = axios.post(url,qs.stringify(data))
    }
    promise.then(
      response =&gt; { // 如果成功了，调用resolve()
        resolve(response.data)
      },
      error =&gt; {  // 如果失败了，不调用reject(),而是提示错误信息
        alert('请求异常:' + error.message)
      }
    )
  })  
}

</code></pre></div><h3 id="有关路由以及项目上线后的地址问题"><a href="#有关路由以及项目上线后的地址问题" class="header-anchor">#</a> 有关路由以及项目上线后的地址问题</h3> <h5 id="路由传参"><a href="#路由传参" class="header-anchor">#</a> 路由传参</h5> <ol><li>query方式(页面刷新数据不会丢失)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>
this.$router.push({path:'/XX', query: {data: value}});
this.$router.replace({path: '/xx', query:{data: value}})

</code></pre></div><ul><li>假设从A页面跳转到B页面，则在B页面的mounted中获取</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
mounted () {
    let val = this.$route.query.data
}

</code></pre></div><ul><li>query方式其实就是将参数放在地址内传过去</li></ul> <ol start="2"><li>params方式（页面刷新会丢失）</li></ol> <div class="language- extra-class"><pre class="language-text"><code>
this.$router.push({path:'/XX', params: {data: value}});
this.$router.replace({path: '/xx', params:{data: value}})

</code></pre></div><ul><li>假设从A页面跳转到B页面，则在B页面的mounted中获取</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
mounted () {
    let val = this.$route.params.data
}

</code></pre></div><ol start="3"><li>直接调用push在路由后面传参(页面刷新数据不会丢失)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>
this.$router.push({
  path: `/B/${id}`,
})
</code></pre></div><ul><li>需要对应路由配置如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
 path: '/B/:id',
 name: 'B',
 component: B
}
</code></pre></div><ul><li>另外页面获取参数如下</li></ul> <div class="language- extra-class"><pre class="language-text"><code>this.$route.params.id
</code></pre></div><h6 id="路由跳转方式"><a href="#路由跳转方式" class="header-anchor">#</a> 路由跳转方式</h6> <ul><li><p>this.$router.push会在浏览器中记录一条页面跳转数据</p></li> <li><p>this.$router.replace并不会在浏览器中记录页面跳转，相当于重指向某个页面</p></li></ul> <h4 id="项目打包上线后刷新404"><a href="#项目打包上线后刷新404" class="header-anchor">#</a> 项目打包上线后刷新404</h4> <h6 id="解决方法-2"><a href="#解决方法-2" class="header-anchor">#</a> 解决方法</h6> <ol><li>如果使用的是history模式只需要改成hash模式</li></ol> <ul><li>只需在路由的配置文件中更改代码如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>export default router = new Router({
 // mode: 'history',
</code></pre></div><ul><li><p>但是改用hash模式的话地址栏会出现一个恶心的#</p></li> <li><p>所以一般都不会使用hash模式</p></li></ul> <ol start="2"><li>使用history模式的话就需要配置nginx</li></ol> <ul><li><p>VUE改成history,打包上线后,404的根本原因是path路径找不到</p></li> <li><p>nginx配置如下</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>server{
    listen       99;# 监听的端口号
    server_name  192.168.1.24 localhost 127.0.0.1; # 生产模式为本机ip 开发模式为localhost
    root &quot;F:/cheduoapp/PHP/mobile&quot;; # 指向前台应用打包后文件位置的根路径
    index index.html;# 默认index页面

    location /html/ {
        if (!-e $request_filename){ #判断是否是一个文件
            rewrite  ^/html/(.*)/(.*)$  /html/$1/index.html last;
        }
    }

    location /html/paydir/ {
        rewrite ^/html/paydir/(.*)-(.*)?(.*)$ /html/$1/index.html?$3 last;
    }

    location /nginx_status
    {
        stub_status on;
        access_log   off;
    }

    location ~ /.*\.(gif|jpg|jpeg|png|bmp|swf)$
    {
        expires      30d;
    }

    location ~ /.*\.(js|css)?$
    {
        expires      12h;
    }

    location ~ /.well-known {
        allow all;
    }

    location ~ /\.
    {
        deny all;
    }
}
</code></pre></div><ul><li>nginx一般都只是配置了一层路由，多层路由的话博主也不会</li></ul> <h5 id="设置指定path的cookie"><a href="#设置指定path的cookie" class="header-anchor">#</a> 设置指定path的cookie</h5> <div class="language- extra-class"><pre class="language-text"><code>export default const setCookie = function (name, value) {
  var str = name + &quot;=&quot; + escape(value) + &quot;;domain=m.cheduo.com;path=/html&quot;;
  var date = new Date();
  date.setTime(date.getTime() + 1 * 24 * 60 * 60 * 1000); //设置date为当前时间加一天
  str += &quot;;expires=&quot; + date.toGMTString();
  console.log(str)
  document.cookie = str;
},
// 获取cookie
export default const getCookie = function(name) {
  var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);
  if(arr=document.cookie.match(reg)){
    return unescape(arr[2]);
  }else{
    return null;
  }
}
</code></pre></div><h4 id="有关页面权限的问题"><a href="#有关页面权限的问题" class="header-anchor">#</a> 有关页面权限的问题</h4> <h6 id="解决方法-3"><a href="#解决方法-3" class="header-anchor">#</a> 解决方法</h6> <ul><li>在配置路由的时候(router/index.js)编写如下代码</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue';
import Router from 'vue-router';
import routes from './router.js';
import store from '../store';
Vue.use(Router)

const router = new Router({
  mode: 'history',
  base: '/html/',
  routes
})
router.beforeEach((to, from, next) =&gt; {
  const getCookie = function(name){
    var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);
    if(arr=document.cookie.match(reg)){
      return unescape(arr[2]);
    }else{
      return null;
    }
  };
  // 可以在路由元信息指定哪些页面需要登录权限
  const token = getCookie('token')
  // const token = store.state.token;
  if (to.meta.requiresAuth &amp;&amp; !token) { // 需要登录授权，这里还需要判断是否登录
    next('/asv/login') // 跳转到登录
    return
  }
  next()
})
export default router;

</code></pre></div><ul><li>再在个个路由中添加如下代码，通过requiresAuth来判断是否需要用户登录</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
    path: 'xx',
    name: 'Xx',
    component: Xx,
    meta: {
      requiresAuth: true
    }
}
</code></pre></div><h5 id="有关移动端键盘的问题"><a href="#有关移动端键盘的问题" class="header-anchor">#</a> 有关移动端键盘的问题</h5> <ul><li>一般只要当input框获取焦点时移动端的键盘就是自动弹起，而且会根据input框的类型弹出响应的键盘</li> <li>可是有时候键盘的弹出会挡住部分输入框或者会导致样式发生变化</li> <li>而且有时候我们会禁掉移动端的键盘</li> <li>禁掉键盘代码如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 只需要在input标签中添加如下代码即可
readonly=&quot;readonly&quot;
</code></pre></div><ul><li>有关键盘弹出造成样式发生变化的解决方法</li></ul> <ol><li><p>尽量不要使用相对屏幕定位</p></li> <li><p>当键盘挡住部分输入框时可以使用以下代码解决：</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>export default function input_on() {
  const u = navigator.userAgent;
  if (u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1) { //安卓手机
    window.addEventListener('resize', function () {
      // Document 对象的activeElement 属性返回文档中当前获得焦点的元素。
      if (document.activeElement.id === 'INPUT') {
        // alert(document.activeElement.getElementsByClassName)
        // console.log('安卓触发', document.activeElement.className)
        window.setTimeout(function() {
          document.activeElement.scrollIntoViewIfNeeded(
            {
              behavior: 'auto',
              block: 'start'
            }
          );
        }, 50);
      }
    })
  }
}
// Element.scrollIntoViewIfNeeded（）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。
// scrollIntoViewIfNeeded可以接受一个Boolean型参数，和scrollIntoView不同，true为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；false时元素可能顶部或底部对齐，视乎元素靠哪边更近。
</code></pre></div><ol><li><p>还有就是当input框输入完毕后移动端键盘消失后有空白区域页面不下滑导致样式发生变化</p> <ul><li>解决方法如下:</li></ul> <div class="language- extra-class"><pre class="language-text"><code> &lt;input type=&quot;tel&quot; name=&quot;mobile&quot; @click=&quot;switchmenu()&quot; v-model=&quot;mobile&quot; maxlength=&quot;11&quot; @blur=&quot;fixScroll&quot;/&gt;
 
fixScroll() { // 解决移动端键盘消失后有空白区域页面不下滑
  let u = navigator.userAgent;
  let isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
  if (isiOS) {
    window.scrollTo(0, 0);
  }
},
</code></pre></div></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myEnd/test.html" class="prev">浏览器缓存及其机制</a></span> <span class="next"><a href="/myEnd/onPay.html">vue移动端支付</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.27194c62.js" defer></script><script src="/assets/js/2.660d2c2d.js" defer></script><script src="/assets/js/30.601df3fc.js" defer></script>
  </body>
</html>
